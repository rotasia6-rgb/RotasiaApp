"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/canvas-confetti";
exports.ids = ["vendor-chunks/canvas-confetti"];
exports.modules = {

/***/ "(ssr)/./node_modules/canvas-confetti/dist/confetti.module.mjs":
/*!***************************************************************!*\
  !*** ./node_modules/canvas-confetti/dist/confetti.module.mjs ***!
  \***************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   create: () => (/* binding */ create),\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n// canvas-confetti v1.9.4 built on 2025-10-25T05:14:56.640Z\nvar module = {};\n// source content\n/* globals Map */ (function main(global, module, isWorker, workerSize) {\n    var canUseWorker = !!(global.Worker && global.Blob && global.Promise && global.OffscreenCanvas && global.OffscreenCanvasRenderingContext2D && global.HTMLCanvasElement && global.HTMLCanvasElement.prototype.transferControlToOffscreen && global.URL && global.URL.createObjectURL);\n    var canUsePaths = typeof Path2D === \"function\" && typeof DOMMatrix === \"function\";\n    var canDrawBitmap = function() {\n        // this mostly supports ssr\n        if (!global.OffscreenCanvas) {\n            return false;\n        }\n        try {\n            var canvas = new OffscreenCanvas(1, 1);\n            var ctx = canvas.getContext(\"2d\");\n            ctx.fillRect(0, 0, 1, 1);\n            var bitmap = canvas.transferToImageBitmap();\n            ctx.createPattern(bitmap, \"no-repeat\");\n        } catch (e) {\n            return false;\n        }\n        return true;\n    }();\n    function noop() {}\n    // create a promise if it exists, otherwise, just\n    // call the function directly\n    function promise(func) {\n        var ModulePromise = module.exports.Promise;\n        var Prom = ModulePromise !== void 0 ? ModulePromise : global.Promise;\n        if (typeof Prom === \"function\") {\n            return new Prom(func);\n        }\n        func(noop, noop);\n        return null;\n    }\n    var bitmapMapper = function(skipTransform, map) {\n        // see https://github.com/catdad/canvas-confetti/issues/209\n        // creating canvases is actually pretty expensive, so we should create a\n        // 1:1 map for bitmap:canvas, so that we can animate the confetti in\n        // a performant manner, but also not store them forever so that we don't\n        // have a memory leak\n        return {\n            transform: function(bitmap) {\n                if (skipTransform) {\n                    return bitmap;\n                }\n                if (map.has(bitmap)) {\n                    return map.get(bitmap);\n                }\n                var canvas = new OffscreenCanvas(bitmap.width, bitmap.height);\n                var ctx = canvas.getContext(\"2d\");\n                ctx.drawImage(bitmap, 0, 0);\n                map.set(bitmap, canvas);\n                return canvas;\n            },\n            clear: function() {\n                map.clear();\n            }\n        };\n    }(canDrawBitmap, new Map());\n    var raf = function() {\n        var TIME = Math.floor(1000 / 60);\n        var frame, cancel;\n        var frames = {};\n        var lastFrameTime = 0;\n        if (typeof requestAnimationFrame === \"function\" && typeof cancelAnimationFrame === \"function\") {\n            frame = function(cb) {\n                var id = Math.random();\n                frames[id] = requestAnimationFrame(function onFrame(time) {\n                    if (lastFrameTime === time || lastFrameTime + TIME - 1 < time) {\n                        lastFrameTime = time;\n                        delete frames[id];\n                        cb();\n                    } else {\n                        frames[id] = requestAnimationFrame(onFrame);\n                    }\n                });\n                return id;\n            };\n            cancel = function(id) {\n                if (frames[id]) {\n                    cancelAnimationFrame(frames[id]);\n                }\n            };\n        } else {\n            frame = function(cb) {\n                return setTimeout(cb, TIME);\n            };\n            cancel = function(timer) {\n                return clearTimeout(timer);\n            };\n        }\n        return {\n            frame: frame,\n            cancel: cancel\n        };\n    }();\n    var getWorker = function() {\n        var worker;\n        var prom;\n        var resolves = {};\n        function decorate(worker) {\n            function execute(options, callback) {\n                worker.postMessage({\n                    options: options || {},\n                    callback: callback\n                });\n            }\n            worker.init = function initWorker(canvas) {\n                var offscreen = canvas.transferControlToOffscreen();\n                worker.postMessage({\n                    canvas: offscreen\n                }, [\n                    offscreen\n                ]);\n            };\n            worker.fire = function fireWorker(options, size, done) {\n                if (prom) {\n                    execute(options, null);\n                    return prom;\n                }\n                var id = Math.random().toString(36).slice(2);\n                prom = promise(function(resolve) {\n                    function workerDone(msg) {\n                        if (msg.data.callback !== id) {\n                            return;\n                        }\n                        delete resolves[id];\n                        worker.removeEventListener(\"message\", workerDone);\n                        prom = null;\n                        bitmapMapper.clear();\n                        done();\n                        resolve();\n                    }\n                    worker.addEventListener(\"message\", workerDone);\n                    execute(options, id);\n                    resolves[id] = workerDone.bind(null, {\n                        data: {\n                            callback: id\n                        }\n                    });\n                });\n                return prom;\n            };\n            worker.reset = function resetWorker() {\n                worker.postMessage({\n                    reset: true\n                });\n                for(var id in resolves){\n                    resolves[id]();\n                    delete resolves[id];\n                }\n            };\n        }\n        return function() {\n            if (worker) {\n                return worker;\n            }\n            if (!isWorker && canUseWorker) {\n                var code = [\n                    \"var CONFETTI, SIZE = {}, module = {};\",\n                    \"(\" + main.toString() + \")(this, module, true, SIZE);\",\n                    \"onmessage = function(msg) {\",\n                    \"  if (msg.data.options) {\",\n                    \"    CONFETTI(msg.data.options).then(function () {\",\n                    \"      if (msg.data.callback) {\",\n                    \"        postMessage({ callback: msg.data.callback });\",\n                    \"      }\",\n                    \"    });\",\n                    \"  } else if (msg.data.reset) {\",\n                    \"    CONFETTI && CONFETTI.reset();\",\n                    \"  } else if (msg.data.resize) {\",\n                    \"    SIZE.width = msg.data.resize.width;\",\n                    \"    SIZE.height = msg.data.resize.height;\",\n                    \"  } else if (msg.data.canvas) {\",\n                    \"    SIZE.width = msg.data.canvas.width;\",\n                    \"    SIZE.height = msg.data.canvas.height;\",\n                    \"    CONFETTI = module.exports.create(msg.data.canvas);\",\n                    \"  }\",\n                    \"}\"\n                ].join(\"\\n\");\n                try {\n                    worker = new Worker(URL.createObjectURL(new Blob([\n                        code\n                    ])));\n                } catch (e) {\n                    // eslint-disable-next-line no-console\n                    typeof console !== \"undefined\" && typeof console.warn === \"function\" ? console.warn(\"\\uD83C\\uDF8A Could not load worker\", e) : null;\n                    return null;\n                }\n                decorate(worker);\n            }\n            return worker;\n        };\n    }();\n    var defaults = {\n        particleCount: 50,\n        angle: 90,\n        spread: 45,\n        startVelocity: 45,\n        decay: 0.9,\n        gravity: 1,\n        drift: 0,\n        ticks: 200,\n        x: 0.5,\n        y: 0.5,\n        shapes: [\n            \"square\",\n            \"circle\"\n        ],\n        zIndex: 100,\n        colors: [\n            \"#26ccff\",\n            \"#a25afd\",\n            \"#ff5e7e\",\n            \"#88ff5a\",\n            \"#fcff42\",\n            \"#ffa62d\",\n            \"#ff36ff\"\n        ],\n        // probably should be true, but back-compat\n        disableForReducedMotion: false,\n        scalar: 1\n    };\n    function convert(val, transform) {\n        return transform ? transform(val) : val;\n    }\n    function isOk(val) {\n        return !(val === null || val === undefined);\n    }\n    function prop(options, name, transform) {\n        return convert(options && isOk(options[name]) ? options[name] : defaults[name], transform);\n    }\n    function onlyPositiveInt(number) {\n        return number < 0 ? 0 : Math.floor(number);\n    }\n    function randomInt(min, max) {\n        // [min, max)\n        return Math.floor(Math.random() * (max - min)) + min;\n    }\n    function toDecimal(str) {\n        return parseInt(str, 16);\n    }\n    function colorsToRgb(colors) {\n        return colors.map(hexToRgb);\n    }\n    function hexToRgb(str) {\n        var val = String(str).replace(/[^0-9a-f]/gi, \"\");\n        if (val.length < 6) {\n            val = val[0] + val[0] + val[1] + val[1] + val[2] + val[2];\n        }\n        return {\n            r: toDecimal(val.substring(0, 2)),\n            g: toDecimal(val.substring(2, 4)),\n            b: toDecimal(val.substring(4, 6))\n        };\n    }\n    function getOrigin(options) {\n        var origin = prop(options, \"origin\", Object);\n        origin.x = prop(origin, \"x\", Number);\n        origin.y = prop(origin, \"y\", Number);\n        return origin;\n    }\n    function setCanvasWindowSize(canvas) {\n        canvas.width = document.documentElement.clientWidth;\n        canvas.height = document.documentElement.clientHeight;\n    }\n    function setCanvasRectSize(canvas) {\n        var rect = canvas.getBoundingClientRect();\n        canvas.width = rect.width;\n        canvas.height = rect.height;\n    }\n    function getCanvas(zIndex) {\n        var canvas = document.createElement(\"canvas\");\n        canvas.style.position = \"fixed\";\n        canvas.style.top = \"0px\";\n        canvas.style.left = \"0px\";\n        canvas.style.pointerEvents = \"none\";\n        canvas.style.zIndex = zIndex;\n        return canvas;\n    }\n    function ellipse(context, x, y, radiusX, radiusY, rotation, startAngle, endAngle, antiClockwise) {\n        context.save();\n        context.translate(x, y);\n        context.rotate(rotation);\n        context.scale(radiusX, radiusY);\n        context.arc(0, 0, 1, startAngle, endAngle, antiClockwise);\n        context.restore();\n    }\n    function randomPhysics(opts) {\n        var radAngle = opts.angle * (Math.PI / 180);\n        var radSpread = opts.spread * (Math.PI / 180);\n        return {\n            x: opts.x,\n            y: opts.y,\n            wobble: Math.random() * 10,\n            wobbleSpeed: Math.min(0.11, Math.random() * 0.1 + 0.05),\n            velocity: opts.startVelocity * 0.5 + Math.random() * opts.startVelocity,\n            angle2D: -radAngle + (0.5 * radSpread - Math.random() * radSpread),\n            tiltAngle: (Math.random() * (0.75 - 0.25) + 0.25) * Math.PI,\n            color: opts.color,\n            shape: opts.shape,\n            tick: 0,\n            totalTicks: opts.ticks,\n            decay: opts.decay,\n            drift: opts.drift,\n            random: Math.random() + 2,\n            tiltSin: 0,\n            tiltCos: 0,\n            wobbleX: 0,\n            wobbleY: 0,\n            gravity: opts.gravity * 3,\n            ovalScalar: 0.6,\n            scalar: opts.scalar,\n            flat: opts.flat\n        };\n    }\n    function updateFetti(context, fetti) {\n        fetti.x += Math.cos(fetti.angle2D) * fetti.velocity + fetti.drift;\n        fetti.y += Math.sin(fetti.angle2D) * fetti.velocity + fetti.gravity;\n        fetti.velocity *= fetti.decay;\n        if (fetti.flat) {\n            fetti.wobble = 0;\n            fetti.wobbleX = fetti.x + 10 * fetti.scalar;\n            fetti.wobbleY = fetti.y + 10 * fetti.scalar;\n            fetti.tiltSin = 0;\n            fetti.tiltCos = 0;\n            fetti.random = 1;\n        } else {\n            fetti.wobble += fetti.wobbleSpeed;\n            fetti.wobbleX = fetti.x + 10 * fetti.scalar * Math.cos(fetti.wobble);\n            fetti.wobbleY = fetti.y + 10 * fetti.scalar * Math.sin(fetti.wobble);\n            fetti.tiltAngle += 0.1;\n            fetti.tiltSin = Math.sin(fetti.tiltAngle);\n            fetti.tiltCos = Math.cos(fetti.tiltAngle);\n            fetti.random = Math.random() + 2;\n        }\n        var progress = fetti.tick++ / fetti.totalTicks;\n        var x1 = fetti.x + fetti.random * fetti.tiltCos;\n        var y1 = fetti.y + fetti.random * fetti.tiltSin;\n        var x2 = fetti.wobbleX + fetti.random * fetti.tiltCos;\n        var y2 = fetti.wobbleY + fetti.random * fetti.tiltSin;\n        context.fillStyle = \"rgba(\" + fetti.color.r + \", \" + fetti.color.g + \", \" + fetti.color.b + \", \" + (1 - progress) + \")\";\n        context.beginPath();\n        if (canUsePaths && fetti.shape.type === \"path\" && typeof fetti.shape.path === \"string\" && Array.isArray(fetti.shape.matrix)) {\n            context.fill(transformPath2D(fetti.shape.path, fetti.shape.matrix, fetti.x, fetti.y, Math.abs(x2 - x1) * 0.1, Math.abs(y2 - y1) * 0.1, Math.PI / 10 * fetti.wobble));\n        } else if (fetti.shape.type === \"bitmap\") {\n            var rotation = Math.PI / 10 * fetti.wobble;\n            var scaleX = Math.abs(x2 - x1) * 0.1;\n            var scaleY = Math.abs(y2 - y1) * 0.1;\n            var width = fetti.shape.bitmap.width * fetti.scalar;\n            var height = fetti.shape.bitmap.height * fetti.scalar;\n            var matrix = new DOMMatrix([\n                Math.cos(rotation) * scaleX,\n                Math.sin(rotation) * scaleX,\n                -Math.sin(rotation) * scaleY,\n                Math.cos(rotation) * scaleY,\n                fetti.x,\n                fetti.y\n            ]);\n            // apply the transform matrix from the confetti shape\n            matrix.multiplySelf(new DOMMatrix(fetti.shape.matrix));\n            var pattern = context.createPattern(bitmapMapper.transform(fetti.shape.bitmap), \"no-repeat\");\n            pattern.setTransform(matrix);\n            context.globalAlpha = 1 - progress;\n            context.fillStyle = pattern;\n            context.fillRect(fetti.x - width / 2, fetti.y - height / 2, width, height);\n            context.globalAlpha = 1;\n        } else if (fetti.shape === \"circle\") {\n            context.ellipse ? context.ellipse(fetti.x, fetti.y, Math.abs(x2 - x1) * fetti.ovalScalar, Math.abs(y2 - y1) * fetti.ovalScalar, Math.PI / 10 * fetti.wobble, 0, 2 * Math.PI) : ellipse(context, fetti.x, fetti.y, Math.abs(x2 - x1) * fetti.ovalScalar, Math.abs(y2 - y1) * fetti.ovalScalar, Math.PI / 10 * fetti.wobble, 0, 2 * Math.PI);\n        } else if (fetti.shape === \"star\") {\n            var rot = Math.PI / 2 * 3;\n            var innerRadius = 4 * fetti.scalar;\n            var outerRadius = 8 * fetti.scalar;\n            var x = fetti.x;\n            var y = fetti.y;\n            var spikes = 5;\n            var step = Math.PI / spikes;\n            while(spikes--){\n                x = fetti.x + Math.cos(rot) * outerRadius;\n                y = fetti.y + Math.sin(rot) * outerRadius;\n                context.lineTo(x, y);\n                rot += step;\n                x = fetti.x + Math.cos(rot) * innerRadius;\n                y = fetti.y + Math.sin(rot) * innerRadius;\n                context.lineTo(x, y);\n                rot += step;\n            }\n        } else {\n            context.moveTo(Math.floor(fetti.x), Math.floor(fetti.y));\n            context.lineTo(Math.floor(fetti.wobbleX), Math.floor(y1));\n            context.lineTo(Math.floor(x2), Math.floor(y2));\n            context.lineTo(Math.floor(x1), Math.floor(fetti.wobbleY));\n        }\n        context.closePath();\n        context.fill();\n        return fetti.tick < fetti.totalTicks;\n    }\n    function animate(canvas, fettis, resizer, size, done) {\n        var animatingFettis = fettis.slice();\n        var context = canvas.getContext(\"2d\");\n        var animationFrame;\n        var destroy;\n        var prom = promise(function(resolve) {\n            function onDone() {\n                animationFrame = destroy = null;\n                context.clearRect(0, 0, size.width, size.height);\n                bitmapMapper.clear();\n                done();\n                resolve();\n            }\n            function update() {\n                if (isWorker && !(size.width === workerSize.width && size.height === workerSize.height)) {\n                    size.width = canvas.width = workerSize.width;\n                    size.height = canvas.height = workerSize.height;\n                }\n                if (!size.width && !size.height) {\n                    resizer(canvas);\n                    size.width = canvas.width;\n                    size.height = canvas.height;\n                }\n                context.clearRect(0, 0, size.width, size.height);\n                animatingFettis = animatingFettis.filter(function(fetti) {\n                    return updateFetti(context, fetti);\n                });\n                if (animatingFettis.length) {\n                    animationFrame = raf.frame(update);\n                } else {\n                    onDone();\n                }\n            }\n            animationFrame = raf.frame(update);\n            destroy = onDone;\n        });\n        return {\n            addFettis: function(fettis) {\n                animatingFettis = animatingFettis.concat(fettis);\n                return prom;\n            },\n            canvas: canvas,\n            promise: prom,\n            reset: function() {\n                if (animationFrame) {\n                    raf.cancel(animationFrame);\n                }\n                if (destroy) {\n                    destroy();\n                }\n            }\n        };\n    }\n    function confettiCannon(canvas, globalOpts) {\n        var isLibCanvas = !canvas;\n        var allowResize = !!prop(globalOpts || {}, \"resize\");\n        var hasResizeEventRegistered = false;\n        var globalDisableForReducedMotion = prop(globalOpts, \"disableForReducedMotion\", Boolean);\n        var shouldUseWorker = canUseWorker && !!prop(globalOpts || {}, \"useWorker\");\n        var worker = shouldUseWorker ? getWorker() : null;\n        var resizer = isLibCanvas ? setCanvasWindowSize : setCanvasRectSize;\n        var initialized = canvas && worker ? !!canvas.__confetti_initialized : false;\n        var preferLessMotion = typeof matchMedia === \"function\" && matchMedia(\"(prefers-reduced-motion)\").matches;\n        var animationObj;\n        function fireLocal(options, size, done) {\n            var particleCount = prop(options, \"particleCount\", onlyPositiveInt);\n            var angle = prop(options, \"angle\", Number);\n            var spread = prop(options, \"spread\", Number);\n            var startVelocity = prop(options, \"startVelocity\", Number);\n            var decay = prop(options, \"decay\", Number);\n            var gravity = prop(options, \"gravity\", Number);\n            var drift = prop(options, \"drift\", Number);\n            var colors = prop(options, \"colors\", colorsToRgb);\n            var ticks = prop(options, \"ticks\", Number);\n            var shapes = prop(options, \"shapes\");\n            var scalar = prop(options, \"scalar\");\n            var flat = !!prop(options, \"flat\");\n            var origin = getOrigin(options);\n            var temp = particleCount;\n            var fettis = [];\n            var startX = canvas.width * origin.x;\n            var startY = canvas.height * origin.y;\n            while(temp--){\n                fettis.push(randomPhysics({\n                    x: startX,\n                    y: startY,\n                    angle: angle,\n                    spread: spread,\n                    startVelocity: startVelocity,\n                    color: colors[temp % colors.length],\n                    shape: shapes[randomInt(0, shapes.length)],\n                    ticks: ticks,\n                    decay: decay,\n                    gravity: gravity,\n                    drift: drift,\n                    scalar: scalar,\n                    flat: flat\n                }));\n            }\n            // if we have a previous canvas already animating,\n            // add to it\n            if (animationObj) {\n                return animationObj.addFettis(fettis);\n            }\n            animationObj = animate(canvas, fettis, resizer, size, done);\n            return animationObj.promise;\n        }\n        function fire(options) {\n            var disableForReducedMotion = globalDisableForReducedMotion || prop(options, \"disableForReducedMotion\", Boolean);\n            var zIndex = prop(options, \"zIndex\", Number);\n            if (disableForReducedMotion && preferLessMotion) {\n                return promise(function(resolve) {\n                    resolve();\n                });\n            }\n            if (isLibCanvas && animationObj) {\n                // use existing canvas from in-progress animation\n                canvas = animationObj.canvas;\n            } else if (isLibCanvas && !canvas) {\n                // create and initialize a new canvas\n                canvas = getCanvas(zIndex);\n                document.body.appendChild(canvas);\n            }\n            if (allowResize && !initialized) {\n                // initialize the size of a user-supplied canvas\n                resizer(canvas);\n            }\n            var size = {\n                width: canvas.width,\n                height: canvas.height\n            };\n            if (worker && !initialized) {\n                worker.init(canvas);\n            }\n            initialized = true;\n            if (worker) {\n                canvas.__confetti_initialized = true;\n            }\n            function onResize() {\n                if (worker) {\n                    // TODO this really shouldn't be immediate, because it is expensive\n                    var obj = {\n                        getBoundingClientRect: function() {\n                            if (!isLibCanvas) {\n                                return canvas.getBoundingClientRect();\n                            }\n                        }\n                    };\n                    resizer(obj);\n                    worker.postMessage({\n                        resize: {\n                            width: obj.width,\n                            height: obj.height\n                        }\n                    });\n                    return;\n                }\n                // don't actually query the size here, since this\n                // can execute frequently and rapidly\n                size.width = size.height = null;\n            }\n            function done() {\n                animationObj = null;\n                if (allowResize) {\n                    hasResizeEventRegistered = false;\n                    global.removeEventListener(\"resize\", onResize);\n                }\n                if (isLibCanvas && canvas) {\n                    if (document.body.contains(canvas)) {\n                        document.body.removeChild(canvas);\n                    }\n                    canvas = null;\n                    initialized = false;\n                }\n            }\n            if (allowResize && !hasResizeEventRegistered) {\n                hasResizeEventRegistered = true;\n                global.addEventListener(\"resize\", onResize, false);\n            }\n            if (worker) {\n                return worker.fire(options, size, done);\n            }\n            return fireLocal(options, size, done);\n        }\n        fire.reset = function() {\n            if (worker) {\n                worker.reset();\n            }\n            if (animationObj) {\n                animationObj.reset();\n            }\n        };\n        return fire;\n    }\n    // Make default export lazy to defer worker creation until called.\n    var defaultFire;\n    function getDefaultFire() {\n        if (!defaultFire) {\n            defaultFire = confettiCannon(null, {\n                useWorker: true,\n                resize: true\n            });\n        }\n        return defaultFire;\n    }\n    function transformPath2D(pathString, pathMatrix, x, y, scaleX, scaleY, rotation) {\n        var path2d = new Path2D(pathString);\n        var t1 = new Path2D();\n        t1.addPath(path2d, new DOMMatrix(pathMatrix));\n        var t2 = new Path2D();\n        // see https://developer.mozilla.org/en-US/docs/Web/API/DOMMatrix/DOMMatrix\n        t2.addPath(t1, new DOMMatrix([\n            Math.cos(rotation) * scaleX,\n            Math.sin(rotation) * scaleX,\n            -Math.sin(rotation) * scaleY,\n            Math.cos(rotation) * scaleY,\n            x,\n            y\n        ]));\n        return t2;\n    }\n    function shapeFromPath(pathData) {\n        if (!canUsePaths) {\n            throw new Error(\"path confetti are not supported in this browser\");\n        }\n        var path, matrix;\n        if (typeof pathData === \"string\") {\n            path = pathData;\n        } else {\n            path = pathData.path;\n            matrix = pathData.matrix;\n        }\n        var path2d = new Path2D(path);\n        var tempCanvas = document.createElement(\"canvas\");\n        var tempCtx = tempCanvas.getContext(\"2d\");\n        if (!matrix) {\n            // attempt to figure out the width of the path, up to 1000x1000\n            var maxSize = 1000;\n            var minX = maxSize;\n            var minY = maxSize;\n            var maxX = 0;\n            var maxY = 0;\n            var width, height;\n            // do some line skipping... this is faster than checking\n            // every pixel and will be mostly still correct\n            for(var x = 0; x < maxSize; x += 2){\n                for(var y = 0; y < maxSize; y += 2){\n                    if (tempCtx.isPointInPath(path2d, x, y, \"nonzero\")) {\n                        minX = Math.min(minX, x);\n                        minY = Math.min(minY, y);\n                        maxX = Math.max(maxX, x);\n                        maxY = Math.max(maxY, y);\n                    }\n                }\n            }\n            width = maxX - minX;\n            height = maxY - minY;\n            var maxDesiredSize = 10;\n            var scale = Math.min(maxDesiredSize / width, maxDesiredSize / height);\n            matrix = [\n                scale,\n                0,\n                0,\n                scale,\n                -Math.round(width / 2 + minX) * scale,\n                -Math.round(height / 2 + minY) * scale\n            ];\n        }\n        return {\n            type: \"path\",\n            path: path,\n            matrix: matrix\n        };\n    }\n    function shapeFromText(textData) {\n        var text, scalar = 1, color = \"#000000\", // see https://nolanlawson.com/2022/04/08/the-struggle-of-using-native-emoji-on-the-web/\n        fontFamily = '\"Apple Color Emoji\", \"Segoe UI Emoji\", \"Segoe UI Symbol\", \"Noto Color Emoji\", \"EmojiOne Color\", \"Android Emoji\", \"Twemoji Mozilla\", \"system emoji\", sans-serif';\n        if (typeof textData === \"string\") {\n            text = textData;\n        } else {\n            text = textData.text;\n            scalar = \"scalar\" in textData ? textData.scalar : scalar;\n            fontFamily = \"fontFamily\" in textData ? textData.fontFamily : fontFamily;\n            color = \"color\" in textData ? textData.color : color;\n        }\n        // all other confetti are 10 pixels,\n        // so this pixel size is the de-facto 100% scale confetti\n        var fontSize = 10 * scalar;\n        var font = \"\" + fontSize + \"px \" + fontFamily;\n        var canvas = new OffscreenCanvas(fontSize, fontSize);\n        var ctx = canvas.getContext(\"2d\");\n        ctx.font = font;\n        var size = ctx.measureText(text);\n        var width = Math.ceil(size.actualBoundingBoxRight + size.actualBoundingBoxLeft);\n        var height = Math.ceil(size.actualBoundingBoxAscent + size.actualBoundingBoxDescent);\n        var padding = 2;\n        var x = size.actualBoundingBoxLeft + padding;\n        var y = size.actualBoundingBoxAscent + padding;\n        width += padding + padding;\n        height += padding + padding;\n        canvas = new OffscreenCanvas(width, height);\n        ctx = canvas.getContext(\"2d\");\n        ctx.font = font;\n        ctx.fillStyle = color;\n        ctx.fillText(text, x, y);\n        var scale = 1 / scalar;\n        return {\n            type: \"bitmap\",\n            // TODO these probably need to be transfered for workers\n            bitmap: canvas.transferToImageBitmap(),\n            matrix: [\n                scale,\n                0,\n                0,\n                scale,\n                -width * scale / 2,\n                -height * scale / 2\n            ]\n        };\n    }\n    module.exports = function() {\n        return getDefaultFire().apply(this, arguments);\n    };\n    module.exports.reset = function() {\n        getDefaultFire().reset();\n    };\n    module.exports.create = confettiCannon;\n    module.exports.shapeFromPath = shapeFromPath;\n    module.exports.shapeFromText = shapeFromText;\n})(function() {\n    if (false) {}\n    if (typeof self !== \"undefined\") {\n        return self;\n    }\n    return this || {};\n}(), module, false);\n// end source content\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (module.exports);\nvar create = module.exports.create;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvY2FudmFzLWNvbmZldHRpL2Rpc3QvY29uZmV0dGkubW9kdWxlLm1qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUFBLDJEQUEyRDtBQUMzRCxJQUFJQSxTQUFTLENBQUM7QUFFZCxpQkFBaUI7QUFDakIsZUFBZSxHQUVkLFVBQVNDLEtBQUtDLE1BQU0sRUFBRUYsTUFBTSxFQUFFRyxRQUFRLEVBQUVDLFVBQVU7SUFDakQsSUFBSUMsZUFBZSxDQUFDLENBQ2xCSCxDQUFBQSxPQUFPSSxNQUFNLElBQ2JKLE9BQU9LLElBQUksSUFDWEwsT0FBT00sT0FBTyxJQUNkTixPQUFPTyxlQUFlLElBQ3RCUCxPQUFPUSxpQ0FBaUMsSUFDeENSLE9BQU9TLGlCQUFpQixJQUN4QlQsT0FBT1MsaUJBQWlCLENBQUNDLFNBQVMsQ0FBQ0MsMEJBQTBCLElBQzdEWCxPQUFPWSxHQUFHLElBQ1ZaLE9BQU9ZLEdBQUcsQ0FBQ0MsZUFBZTtJQUU1QixJQUFJQyxjQUFjLE9BQU9DLFdBQVcsY0FBYyxPQUFPQyxjQUFjO0lBQ3ZFLElBQUlDLGdCQUFnQjtRQUNsQiwyQkFBMkI7UUFDM0IsSUFBSSxDQUFDakIsT0FBT08sZUFBZSxFQUFFO1lBQzNCLE9BQU87UUFDVDtRQUVBLElBQUk7WUFDRixJQUFJVyxTQUFTLElBQUlYLGdCQUFnQixHQUFHO1lBQ3BDLElBQUlZLE1BQU1ELE9BQU9FLFVBQVUsQ0FBQztZQUM1QkQsSUFBSUUsUUFBUSxDQUFDLEdBQUcsR0FBRyxHQUFHO1lBQ3RCLElBQUlDLFNBQVNKLE9BQU9LLHFCQUFxQjtZQUN6Q0osSUFBSUssYUFBYSxDQUFDRixRQUFRO1FBQzVCLEVBQUUsT0FBT0csR0FBRztZQUNWLE9BQU87UUFDVDtRQUVBLE9BQU87SUFDVDtJQUVBLFNBQVNDLFFBQVE7SUFFakIsaURBQWlEO0lBQ2pELDZCQUE2QjtJQUM3QixTQUFTQyxRQUFRQyxJQUFJO1FBQ25CLElBQUlDLGdCQUFnQi9CLE9BQU9nQyxPQUFPLENBQUN4QixP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QU0sQ0FBQyIsInNvdXJjZXMiOlsid2VicGFjazovL3JvdGFzaWEtYXBwLy4vbm9kZV9tb2R1bGVzL2NhbnZhcy1jb25mZXR0aS9kaXN0L2NvbmZldHRpLm1vZHVsZS5tanM/ZjFlNCJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBjYW52YXMtY29uZmV0dGkgdjEuOS40IGJ1aWx0IG9uIDIwMjUtMTAtMjVUMDU6MTQ6NTYuNjQwWlxudmFyIG1vZHVsZSA9IHt9O1xuXG4vLyBzb3VyY2UgY29udGVudFxuLyogZ2xvYmFscyBNYXAgKi9cblxuKGZ1bmN0aW9uIG1haW4oZ2xvYmFsLCBtb2R1bGUsIGlzV29ya2VyLCB3b3JrZXJTaXplKSB7XG4gIHZhciBjYW5Vc2VXb3JrZXIgPSAhIShcbiAgICBnbG9iYWwuV29ya2VyICYmXG4gICAgZ2xvYmFsLkJsb2IgJiZcbiAgICBnbG9iYWwuUHJvbWlzZSAmJlxuICAgIGdsb2JhbC5PZmZzY3JlZW5DYW52YXMgJiZcbiAgICBnbG9iYWwuT2Zmc2NyZWVuQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJEICYmXG4gICAgZ2xvYmFsLkhUTUxDYW52YXNFbGVtZW50ICYmXG4gICAgZ2xvYmFsLkhUTUxDYW52YXNFbGVtZW50LnByb3RvdHlwZS50cmFuc2ZlckNvbnRyb2xUb09mZnNjcmVlbiAmJlxuICAgIGdsb2JhbC5VUkwgJiZcbiAgICBnbG9iYWwuVVJMLmNyZWF0ZU9iamVjdFVSTCk7XG5cbiAgdmFyIGNhblVzZVBhdGhzID0gdHlwZW9mIFBhdGgyRCA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgRE9NTWF0cml4ID09PSAnZnVuY3Rpb24nO1xuICB2YXIgY2FuRHJhd0JpdG1hcCA9IChmdW5jdGlvbiAoKSB7XG4gICAgLy8gdGhpcyBtb3N0bHkgc3VwcG9ydHMgc3NyXG4gICAgaWYgKCFnbG9iYWwuT2Zmc2NyZWVuQ2FudmFzKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgIHZhciBjYW52YXMgPSBuZXcgT2Zmc2NyZWVuQ2FudmFzKDEsIDEpO1xuICAgICAgdmFyIGN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuICAgICAgY3R4LmZpbGxSZWN0KDAsIDAsIDEsIDEpO1xuICAgICAgdmFyIGJpdG1hcCA9IGNhbnZhcy50cmFuc2ZlclRvSW1hZ2VCaXRtYXAoKTtcbiAgICAgIGN0eC5jcmVhdGVQYXR0ZXJuKGJpdG1hcCwgJ25vLXJlcGVhdCcpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSkoKTtcblxuICBmdW5jdGlvbiBub29wKCkge31cblxuICAvLyBjcmVhdGUgYSBwcm9taXNlIGlmIGl0IGV4aXN0cywgb3RoZXJ3aXNlLCBqdXN0XG4gIC8vIGNhbGwgdGhlIGZ1bmN0aW9uIGRpcmVjdGx5XG4gIGZ1bmN0aW9uIHByb21pc2UoZnVuYykge1xuICAgIHZhciBNb2R1bGVQcm9taXNlID0gbW9kdWxlLmV4cG9ydHMuUHJvbWlzZTtcbiAgICB2YXIgUHJvbSA9IE1vZHVsZVByb21pc2UgIT09IHZvaWQgMCA/IE1vZHVsZVByb21pc2UgOiBnbG9iYWwuUHJvbWlzZTtcblxuICAgIGlmICh0eXBlb2YgUHJvbSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcmV0dXJuIG5ldyBQcm9tKGZ1bmMpO1xuICAgIH1cblxuICAgIGZ1bmMobm9vcCwgbm9vcCk7XG5cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHZhciBiaXRtYXBNYXBwZXIgPSAoZnVuY3Rpb24gKHNraXBUcmFuc2Zvcm0sIG1hcCkge1xuICAgIC8vIHNlZSBodHRwczovL2dpdGh1Yi5jb20vY2F0ZGFkL2NhbnZhcy1jb25mZXR0aS9pc3N1ZXMvMjA5XG4gICAgLy8gY3JlYXRpbmcgY2FudmFzZXMgaXMgYWN0dWFsbHkgcHJldHR5IGV4cGVuc2l2ZSwgc28gd2Ugc2hvdWxkIGNyZWF0ZSBhXG4gICAgLy8gMToxIG1hcCBmb3IgYml0bWFwOmNhbnZhcywgc28gdGhhdCB3ZSBjYW4gYW5pbWF0ZSB0aGUgY29uZmV0dGkgaW5cbiAgICAvLyBhIHBlcmZvcm1hbnQgbWFubmVyLCBidXQgYWxzbyBub3Qgc3RvcmUgdGhlbSBmb3JldmVyIHNvIHRoYXQgd2UgZG9uJ3RcbiAgICAvLyBoYXZlIGEgbWVtb3J5IGxlYWtcbiAgICByZXR1cm4ge1xuICAgICAgdHJhbnNmb3JtOiBmdW5jdGlvbihiaXRtYXApIHtcbiAgICAgICAgaWYgKHNraXBUcmFuc2Zvcm0pIHtcbiAgICAgICAgICByZXR1cm4gYml0bWFwO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG1hcC5oYXMoYml0bWFwKSkge1xuICAgICAgICAgIHJldHVybiBtYXAuZ2V0KGJpdG1hcCk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgY2FudmFzID0gbmV3IE9mZnNjcmVlbkNhbnZhcyhiaXRtYXAud2lkdGgsIGJpdG1hcC5oZWlnaHQpO1xuICAgICAgICB2YXIgY3R4ID0gY2FudmFzLmdldENvbnRleHQoJzJkJyk7XG4gICAgICAgIGN0eC5kcmF3SW1hZ2UoYml0bWFwLCAwLCAwKTtcblxuICAgICAgICBtYXAuc2V0KGJpdG1hcCwgY2FudmFzKTtcblxuICAgICAgICByZXR1cm4gY2FudmFzO1xuICAgICAgfSxcbiAgICAgIGNsZWFyOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIG1hcC5jbGVhcigpO1xuICAgICAgfVxuICAgIH07XG4gIH0pKGNhbkRyYXdCaXRtYXAsIG5ldyBNYXAoKSk7XG5cbiAgdmFyIHJhZiA9IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIFRJTUUgPSBNYXRoLmZsb29yKDEwMDAgLyA2MCk7XG4gICAgdmFyIGZyYW1lLCBjYW5jZWw7XG4gICAgdmFyIGZyYW1lcyA9IHt9O1xuICAgIHZhciBsYXN0RnJhbWVUaW1lID0gMDtcblxuICAgIGlmICh0eXBlb2YgcmVxdWVzdEFuaW1hdGlvbkZyYW1lID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBjYW5jZWxBbmltYXRpb25GcmFtZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgZnJhbWUgPSBmdW5jdGlvbiAoY2IpIHtcbiAgICAgICAgdmFyIGlkID0gTWF0aC5yYW5kb20oKTtcblxuICAgICAgICBmcmFtZXNbaWRdID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGZ1bmN0aW9uIG9uRnJhbWUodGltZSkge1xuICAgICAgICAgIGlmIChsYXN0RnJhbWVUaW1lID09PSB0aW1lIHx8IGxhc3RGcmFtZVRpbWUgKyBUSU1FIC0gMSA8IHRpbWUpIHtcbiAgICAgICAgICAgIGxhc3RGcmFtZVRpbWUgPSB0aW1lO1xuICAgICAgICAgICAgZGVsZXRlIGZyYW1lc1tpZF07XG5cbiAgICAgICAgICAgIGNiKCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGZyYW1lc1tpZF0gPSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUob25GcmFtZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gaWQ7XG4gICAgICB9O1xuICAgICAgY2FuY2VsID0gZnVuY3Rpb24gKGlkKSB7XG4gICAgICAgIGlmIChmcmFtZXNbaWRdKSB7XG4gICAgICAgICAgY2FuY2VsQW5pbWF0aW9uRnJhbWUoZnJhbWVzW2lkXSk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIGZyYW1lID0gZnVuY3Rpb24gKGNiKSB7XG4gICAgICAgIHJldHVybiBzZXRUaW1lb3V0KGNiLCBUSU1FKTtcbiAgICAgIH07XG4gICAgICBjYW5jZWwgPSBmdW5jdGlvbiAodGltZXIpIHtcbiAgICAgICAgcmV0dXJuIGNsZWFyVGltZW91dCh0aW1lcik7XG4gICAgICB9O1xuICAgIH1cblxuICAgIHJldHVybiB7IGZyYW1lOiBmcmFtZSwgY2FuY2VsOiBjYW5jZWwgfTtcbiAgfSgpKTtcblxuICB2YXIgZ2V0V29ya2VyID0gKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgd29ya2VyO1xuICAgIHZhciBwcm9tO1xuICAgIHZhciByZXNvbHZlcyA9IHt9O1xuXG4gICAgZnVuY3Rpb24gZGVjb3JhdGUod29ya2VyKSB7XG4gICAgICBmdW5jdGlvbiBleGVjdXRlKG9wdGlvbnMsIGNhbGxiYWNrKSB7XG4gICAgICAgIHdvcmtlci5wb3N0TWVzc2FnZSh7IG9wdGlvbnM6IG9wdGlvbnMgfHwge30sIGNhbGxiYWNrOiBjYWxsYmFjayB9KTtcbiAgICAgIH1cbiAgICAgIHdvcmtlci5pbml0ID0gZnVuY3Rpb24gaW5pdFdvcmtlcihjYW52YXMpIHtcbiAgICAgICAgdmFyIG9mZnNjcmVlbiA9IGNhbnZhcy50cmFuc2ZlckNvbnRyb2xUb09mZnNjcmVlbigpO1xuICAgICAgICB3b3JrZXIucG9zdE1lc3NhZ2UoeyBjYW52YXM6IG9mZnNjcmVlbiB9LCBbb2Zmc2NyZWVuXSk7XG4gICAgICB9O1xuXG4gICAgICB3b3JrZXIuZmlyZSA9IGZ1bmN0aW9uIGZpcmVXb3JrZXIob3B0aW9ucywgc2l6ZSwgZG9uZSkge1xuICAgICAgICBpZiAocHJvbSkge1xuICAgICAgICAgIGV4ZWN1dGUob3B0aW9ucywgbnVsbCk7XG4gICAgICAgICAgcmV0dXJuIHByb207XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgaWQgPSBNYXRoLnJhbmRvbSgpLnRvU3RyaW5nKDM2KS5zbGljZSgyKTtcblxuICAgICAgICBwcm9tID0gcHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSkge1xuICAgICAgICAgIGZ1bmN0aW9uIHdvcmtlckRvbmUobXNnKSB7XG4gICAgICAgICAgICBpZiAobXNnLmRhdGEuY2FsbGJhY2sgIT09IGlkKSB7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZGVsZXRlIHJlc29sdmVzW2lkXTtcbiAgICAgICAgICAgIHdvcmtlci5yZW1vdmVFdmVudExpc3RlbmVyKCdtZXNzYWdlJywgd29ya2VyRG9uZSk7XG5cbiAgICAgICAgICAgIHByb20gPSBudWxsO1xuXG4gICAgICAgICAgICBiaXRtYXBNYXBwZXIuY2xlYXIoKTtcblxuICAgICAgICAgICAgZG9uZSgpO1xuICAgICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHdvcmtlci5hZGRFdmVudExpc3RlbmVyKCdtZXNzYWdlJywgd29ya2VyRG9uZSk7XG4gICAgICAgICAgZXhlY3V0ZShvcHRpb25zLCBpZCk7XG5cbiAgICAgICAgICByZXNvbHZlc1tpZF0gPSB3b3JrZXJEb25lLmJpbmQobnVsbCwgeyBkYXRhOiB7IGNhbGxiYWNrOiBpZCB9fSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiBwcm9tO1xuICAgICAgfTtcblxuICAgICAgd29ya2VyLnJlc2V0ID0gZnVuY3Rpb24gcmVzZXRXb3JrZXIoKSB7XG4gICAgICAgIHdvcmtlci5wb3N0TWVzc2FnZSh7IHJlc2V0OiB0cnVlIH0pO1xuXG4gICAgICAgIGZvciAodmFyIGlkIGluIHJlc29sdmVzKSB7XG4gICAgICAgICAgcmVzb2x2ZXNbaWRdKCk7XG4gICAgICAgICAgZGVsZXRlIHJlc29sdmVzW2lkXTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKHdvcmtlcikge1xuICAgICAgICByZXR1cm4gd29ya2VyO1xuICAgICAgfVxuXG4gICAgICBpZiAoIWlzV29ya2VyICYmIGNhblVzZVdvcmtlcikge1xuICAgICAgICB2YXIgY29kZSA9IFtcbiAgICAgICAgICAndmFyIENPTkZFVFRJLCBTSVpFID0ge30sIG1vZHVsZSA9IHt9OycsXG4gICAgICAgICAgJygnICsgbWFpbi50b1N0cmluZygpICsgJykodGhpcywgbW9kdWxlLCB0cnVlLCBTSVpFKTsnLFxuICAgICAgICAgICdvbm1lc3NhZ2UgPSBmdW5jdGlvbihtc2cpIHsnLFxuICAgICAgICAgICcgIGlmIChtc2cuZGF0YS5vcHRpb25zKSB7JyxcbiAgICAgICAgICAnICAgIENPTkZFVFRJKG1zZy5kYXRhLm9wdGlvbnMpLnRoZW4oZnVuY3Rpb24gKCkgeycsXG4gICAgICAgICAgJyAgICAgIGlmIChtc2cuZGF0YS5jYWxsYmFjaykgeycsXG4gICAgICAgICAgJyAgICAgICAgcG9zdE1lc3NhZ2UoeyBjYWxsYmFjazogbXNnLmRhdGEuY2FsbGJhY2sgfSk7JyxcbiAgICAgICAgICAnICAgICAgfScsXG4gICAgICAgICAgJyAgICB9KTsnLFxuICAgICAgICAgICcgIH0gZWxzZSBpZiAobXNnLmRhdGEucmVzZXQpIHsnLFxuICAgICAgICAgICcgICAgQ09ORkVUVEkgJiYgQ09ORkVUVEkucmVzZXQoKTsnLFxuICAgICAgICAgICcgIH0gZWxzZSBpZiAobXNnLmRhdGEucmVzaXplKSB7JyxcbiAgICAgICAgICAnICAgIFNJWkUud2lkdGggPSBtc2cuZGF0YS5yZXNpemUud2lkdGg7JyxcbiAgICAgICAgICAnICAgIFNJWkUuaGVpZ2h0ID0gbXNnLmRhdGEucmVzaXplLmhlaWdodDsnLFxuICAgICAgICAgICcgIH0gZWxzZSBpZiAobXNnLmRhdGEuY2FudmFzKSB7JyxcbiAgICAgICAgICAnICAgIFNJWkUud2lkdGggPSBtc2cuZGF0YS5jYW52YXMud2lkdGg7JyxcbiAgICAgICAgICAnICAgIFNJWkUuaGVpZ2h0ID0gbXNnLmRhdGEuY2FudmFzLmhlaWdodDsnLFxuICAgICAgICAgICcgICAgQ09ORkVUVEkgPSBtb2R1bGUuZXhwb3J0cy5jcmVhdGUobXNnLmRhdGEuY2FudmFzKTsnLFxuICAgICAgICAgICcgIH0nLFxuICAgICAgICAgICd9JyxcbiAgICAgICAgXS5qb2luKCdcXG4nKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICB3b3JrZXIgPSBuZXcgV29ya2VyKFVSTC5jcmVhdGVPYmplY3RVUkwobmV3IEJsb2IoW2NvZGVdKSkpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnNvbGVcbiAgICAgICAgICB0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIGNvbnNvbGUud2FybiA9PT0gJ2Z1bmN0aW9uJyA/IGNvbnNvbGUud2Fybign8J+OiiBDb3VsZCBub3QgbG9hZCB3b3JrZXInLCBlKSA6IG51bGw7XG5cbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIGRlY29yYXRlKHdvcmtlcik7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB3b3JrZXI7XG4gICAgfTtcbiAgfSkoKTtcblxuICB2YXIgZGVmYXVsdHMgPSB7XG4gICAgcGFydGljbGVDb3VudDogNTAsXG4gICAgYW5nbGU6IDkwLFxuICAgIHNwcmVhZDogNDUsXG4gICAgc3RhcnRWZWxvY2l0eTogNDUsXG4gICAgZGVjYXk6IDAuOSxcbiAgICBncmF2aXR5OiAxLFxuICAgIGRyaWZ0OiAwLFxuICAgIHRpY2tzOiAyMDAsXG4gICAgeDogMC41LFxuICAgIHk6IDAuNSxcbiAgICBzaGFwZXM6IFsnc3F1YXJlJywgJ2NpcmNsZSddLFxuICAgIHpJbmRleDogMTAwLFxuICAgIGNvbG9yczogW1xuICAgICAgJyMyNmNjZmYnLFxuICAgICAgJyNhMjVhZmQnLFxuICAgICAgJyNmZjVlN2UnLFxuICAgICAgJyM4OGZmNWEnLFxuICAgICAgJyNmY2ZmNDInLFxuICAgICAgJyNmZmE2MmQnLFxuICAgICAgJyNmZjM2ZmYnXG4gICAgXSxcbiAgICAvLyBwcm9iYWJseSBzaG91bGQgYmUgdHJ1ZSwgYnV0IGJhY2stY29tcGF0XG4gICAgZGlzYWJsZUZvclJlZHVjZWRNb3Rpb246IGZhbHNlLFxuICAgIHNjYWxhcjogMVxuICB9O1xuXG4gIGZ1bmN0aW9uIGNvbnZlcnQodmFsLCB0cmFuc2Zvcm0pIHtcbiAgICByZXR1cm4gdHJhbnNmb3JtID8gdHJhbnNmb3JtKHZhbCkgOiB2YWw7XG4gIH1cblxuICBmdW5jdGlvbiBpc09rKHZhbCkge1xuICAgIHJldHVybiAhKHZhbCA9PT0gbnVsbCB8fCB2YWwgPT09IHVuZGVmaW5lZCk7XG4gIH1cblxuICBmdW5jdGlvbiBwcm9wKG9wdGlvbnMsIG5hbWUsIHRyYW5zZm9ybSkge1xuICAgIHJldHVybiBjb252ZXJ0KFxuICAgICAgb3B0aW9ucyAmJiBpc09rKG9wdGlvbnNbbmFtZV0pID8gb3B0aW9uc1tuYW1lXSA6IGRlZmF1bHRzW25hbWVdLFxuICAgICAgdHJhbnNmb3JtXG4gICAgKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG9ubHlQb3NpdGl2ZUludChudW1iZXIpe1xuICAgIHJldHVybiBudW1iZXIgPCAwID8gMCA6IE1hdGguZmxvb3IobnVtYmVyKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJhbmRvbUludChtaW4sIG1heCkge1xuICAgIC8vIFttaW4sIG1heClcbiAgICByZXR1cm4gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogKG1heCAtIG1pbikpICsgbWluO1xuICB9XG5cbiAgZnVuY3Rpb24gdG9EZWNpbWFsKHN0cikge1xuICAgIHJldHVybiBwYXJzZUludChzdHIsIDE2KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNvbG9yc1RvUmdiKGNvbG9ycykge1xuICAgIHJldHVybiBjb2xvcnMubWFwKGhleFRvUmdiKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGhleFRvUmdiKHN0cikge1xuICAgIHZhciB2YWwgPSBTdHJpbmcoc3RyKS5yZXBsYWNlKC9bXjAtOWEtZl0vZ2ksICcnKTtcblxuICAgIGlmICh2YWwubGVuZ3RoIDwgNikge1xuICAgICAgICB2YWwgPSB2YWxbMF0rdmFsWzBdK3ZhbFsxXSt2YWxbMV0rdmFsWzJdK3ZhbFsyXTtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgcjogdG9EZWNpbWFsKHZhbC5zdWJzdHJpbmcoMCwyKSksXG4gICAgICBnOiB0b0RlY2ltYWwodmFsLnN1YnN0cmluZygyLDQpKSxcbiAgICAgIGI6IHRvRGVjaW1hbCh2YWwuc3Vic3RyaW5nKDQsNikpXG4gICAgfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldE9yaWdpbihvcHRpb25zKSB7XG4gICAgdmFyIG9yaWdpbiA9IHByb3Aob3B0aW9ucywgJ29yaWdpbicsIE9iamVjdCk7XG4gICAgb3JpZ2luLnggPSBwcm9wKG9yaWdpbiwgJ3gnLCBOdW1iZXIpO1xuICAgIG9yaWdpbi55ID0gcHJvcChvcmlnaW4sICd5JywgTnVtYmVyKTtcblxuICAgIHJldHVybiBvcmlnaW47XG4gIH1cblxuICBmdW5jdGlvbiBzZXRDYW52YXNXaW5kb3dTaXplKGNhbnZhcykge1xuICAgIGNhbnZhcy53aWR0aCA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGllbnRXaWR0aDtcbiAgICBjYW52YXMuaGVpZ2h0ID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsaWVudEhlaWdodDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHNldENhbnZhc1JlY3RTaXplKGNhbnZhcykge1xuICAgIHZhciByZWN0ID0gY2FudmFzLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIGNhbnZhcy53aWR0aCA9IHJlY3Qud2lkdGg7XG4gICAgY2FudmFzLmhlaWdodCA9IHJlY3QuaGVpZ2h0O1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0Q2FudmFzKHpJbmRleCkge1xuICAgIHZhciBjYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcblxuICAgIGNhbnZhcy5zdHlsZS5wb3NpdGlvbiA9ICdmaXhlZCc7XG4gICAgY2FudmFzLnN0eWxlLnRvcCA9ICcwcHgnO1xuICAgIGNhbnZhcy5zdHlsZS5sZWZ0ID0gJzBweCc7XG4gICAgY2FudmFzLnN0eWxlLnBvaW50ZXJFdmVudHMgPSAnbm9uZSc7XG4gICAgY2FudmFzLnN0eWxlLnpJbmRleCA9IHpJbmRleDtcblxuICAgIHJldHVybiBjYW52YXM7XG4gIH1cblxuICBmdW5jdGlvbiBlbGxpcHNlKGNvbnRleHQsIHgsIHksIHJhZGl1c1gsIHJhZGl1c1ksIHJvdGF0aW9uLCBzdGFydEFuZ2xlLCBlbmRBbmdsZSwgYW50aUNsb2Nrd2lzZSkge1xuICAgIGNvbnRleHQuc2F2ZSgpO1xuICAgIGNvbnRleHQudHJhbnNsYXRlKHgsIHkpO1xuICAgIGNvbnRleHQucm90YXRlKHJvdGF0aW9uKTtcbiAgICBjb250ZXh0LnNjYWxlKHJhZGl1c1gsIHJhZGl1c1kpO1xuICAgIGNvbnRleHQuYXJjKDAsIDAsIDEsIHN0YXJ0QW5nbGUsIGVuZEFuZ2xlLCBhbnRpQ2xvY2t3aXNlKTtcbiAgICBjb250ZXh0LnJlc3RvcmUoKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJhbmRvbVBoeXNpY3Mob3B0cykge1xuICAgIHZhciByYWRBbmdsZSA9IG9wdHMuYW5nbGUgKiAoTWF0aC5QSSAvIDE4MCk7XG4gICAgdmFyIHJhZFNwcmVhZCA9IG9wdHMuc3ByZWFkICogKE1hdGguUEkgLyAxODApO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIHg6IG9wdHMueCxcbiAgICAgIHk6IG9wdHMueSxcbiAgICAgIHdvYmJsZTogTWF0aC5yYW5kb20oKSAqIDEwLFxuICAgICAgd29iYmxlU3BlZWQ6IE1hdGgubWluKDAuMTEsIE1hdGgucmFuZG9tKCkgKiAwLjEgKyAwLjA1KSxcbiAgICAgIHZlbG9jaXR5OiAob3B0cy5zdGFydFZlbG9jaXR5ICogMC41KSArIChNYXRoLnJhbmRvbSgpICogb3B0cy5zdGFydFZlbG9jaXR5KSxcbiAgICAgIGFuZ2xlMkQ6IC1yYWRBbmdsZSArICgoMC41ICogcmFkU3ByZWFkKSAtIChNYXRoLnJhbmRvbSgpICogcmFkU3ByZWFkKSksXG4gICAgICB0aWx0QW5nbGU6IChNYXRoLnJhbmRvbSgpICogKDAuNzUgLSAwLjI1KSArIDAuMjUpICogTWF0aC5QSSxcbiAgICAgIGNvbG9yOiBvcHRzLmNvbG9yLFxuICAgICAgc2hhcGU6IG9wdHMuc2hhcGUsXG4gICAgICB0aWNrOiAwLFxuICAgICAgdG90YWxUaWNrczogb3B0cy50aWNrcyxcbiAgICAgIGRlY2F5OiBvcHRzLmRlY2F5LFxuICAgICAgZHJpZnQ6IG9wdHMuZHJpZnQsXG4gICAgICByYW5kb206IE1hdGgucmFuZG9tKCkgKyAyLFxuICAgICAgdGlsdFNpbjogMCxcbiAgICAgIHRpbHRDb3M6IDAsXG4gICAgICB3b2JibGVYOiAwLFxuICAgICAgd29iYmxlWTogMCxcbiAgICAgIGdyYXZpdHk6IG9wdHMuZ3Jhdml0eSAqIDMsXG4gICAgICBvdmFsU2NhbGFyOiAwLjYsXG4gICAgICBzY2FsYXI6IG9wdHMuc2NhbGFyLFxuICAgICAgZmxhdDogb3B0cy5mbGF0XG4gICAgfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHVwZGF0ZUZldHRpKGNvbnRleHQsIGZldHRpKSB7XG4gICAgZmV0dGkueCArPSBNYXRoLmNvcyhmZXR0aS5hbmdsZTJEKSAqIGZldHRpLnZlbG9jaXR5ICsgZmV0dGkuZHJpZnQ7XG4gICAgZmV0dGkueSArPSBNYXRoLnNpbihmZXR0aS5hbmdsZTJEKSAqIGZldHRpLnZlbG9jaXR5ICsgZmV0dGkuZ3Jhdml0eTtcbiAgICBmZXR0aS52ZWxvY2l0eSAqPSBmZXR0aS5kZWNheTtcblxuICAgIGlmIChmZXR0aS5mbGF0KSB7XG4gICAgICBmZXR0aS53b2JibGUgPSAwO1xuICAgICAgZmV0dGkud29iYmxlWCA9IGZldHRpLnggKyAoMTAgKiBmZXR0aS5zY2FsYXIpO1xuICAgICAgZmV0dGkud29iYmxlWSA9IGZldHRpLnkgKyAoMTAgKiBmZXR0aS5zY2FsYXIpO1xuXG4gICAgICBmZXR0aS50aWx0U2luID0gMDtcbiAgICAgIGZldHRpLnRpbHRDb3MgPSAwO1xuICAgICAgZmV0dGkucmFuZG9tID0gMTtcbiAgICB9IGVsc2Uge1xuICAgICAgZmV0dGkud29iYmxlICs9IGZldHRpLndvYmJsZVNwZWVkO1xuICAgICAgZmV0dGkud29iYmxlWCA9IGZldHRpLnggKyAoKDEwICogZmV0dGkuc2NhbGFyKSAqIE1hdGguY29zKGZldHRpLndvYmJsZSkpO1xuICAgICAgZmV0dGkud29iYmxlWSA9IGZldHRpLnkgKyAoKDEwICogZmV0dGkuc2NhbGFyKSAqIE1hdGguc2luKGZldHRpLndvYmJsZSkpO1xuXG4gICAgICBmZXR0aS50aWx0QW5nbGUgKz0gMC4xO1xuICAgICAgZmV0dGkudGlsdFNpbiA9IE1hdGguc2luKGZldHRpLnRpbHRBbmdsZSk7XG4gICAgICBmZXR0aS50aWx0Q29zID0gTWF0aC5jb3MoZmV0dGkudGlsdEFuZ2xlKTtcbiAgICAgIGZldHRpLnJhbmRvbSA9IE1hdGgucmFuZG9tKCkgKyAyO1xuICAgIH1cblxuICAgIHZhciBwcm9ncmVzcyA9IChmZXR0aS50aWNrKyspIC8gZmV0dGkudG90YWxUaWNrcztcblxuICAgIHZhciB4MSA9IGZldHRpLnggKyAoZmV0dGkucmFuZG9tICogZmV0dGkudGlsdENvcyk7XG4gICAgdmFyIHkxID0gZmV0dGkueSArIChmZXR0aS5yYW5kb20gKiBmZXR0aS50aWx0U2luKTtcbiAgICB2YXIgeDIgPSBmZXR0aS53b2JibGVYICsgKGZldHRpLnJhbmRvbSAqIGZldHRpLnRpbHRDb3MpO1xuICAgIHZhciB5MiA9IGZldHRpLndvYmJsZVkgKyAoZmV0dGkucmFuZG9tICogZmV0dGkudGlsdFNpbik7XG5cbiAgICBjb250ZXh0LmZpbGxTdHlsZSA9ICdyZ2JhKCcgKyBmZXR0aS5jb2xvci5yICsgJywgJyArIGZldHRpLmNvbG9yLmcgKyAnLCAnICsgZmV0dGkuY29sb3IuYiArICcsICcgKyAoMSAtIHByb2dyZXNzKSArICcpJztcblxuICAgIGNvbnRleHQuYmVnaW5QYXRoKCk7XG5cbiAgICBpZiAoY2FuVXNlUGF0aHMgJiYgZmV0dGkuc2hhcGUudHlwZSA9PT0gJ3BhdGgnICYmIHR5cGVvZiBmZXR0aS5zaGFwZS5wYXRoID09PSAnc3RyaW5nJyAmJiBBcnJheS5pc0FycmF5KGZldHRpLnNoYXBlLm1hdHJpeCkpIHtcbiAgICAgIGNvbnRleHQuZmlsbCh0cmFuc2Zvcm1QYXRoMkQoXG4gICAgICAgIGZldHRpLnNoYXBlLnBhdGgsXG4gICAgICAgIGZldHRpLnNoYXBlLm1hdHJpeCxcbiAgICAgICAgZmV0dGkueCxcbiAgICAgICAgZmV0dGkueSxcbiAgICAgICAgTWF0aC5hYnMoeDIgLSB4MSkgKiAwLjEsXG4gICAgICAgIE1hdGguYWJzKHkyIC0geTEpICogMC4xLFxuICAgICAgICBNYXRoLlBJIC8gMTAgKiBmZXR0aS53b2JibGVcbiAgICAgICkpO1xuICAgIH0gZWxzZSBpZiAoZmV0dGkuc2hhcGUudHlwZSA9PT0gJ2JpdG1hcCcpIHtcbiAgICAgIHZhciByb3RhdGlvbiA9IE1hdGguUEkgLyAxMCAqIGZldHRpLndvYmJsZTtcbiAgICAgIHZhciBzY2FsZVggPSBNYXRoLmFicyh4MiAtIHgxKSAqIDAuMTtcbiAgICAgIHZhciBzY2FsZVkgPSBNYXRoLmFicyh5MiAtIHkxKSAqIDAuMTtcbiAgICAgIHZhciB3aWR0aCA9IGZldHRpLnNoYXBlLmJpdG1hcC53aWR0aCAqIGZldHRpLnNjYWxhcjtcbiAgICAgIHZhciBoZWlnaHQgPSBmZXR0aS5zaGFwZS5iaXRtYXAuaGVpZ2h0ICogZmV0dGkuc2NhbGFyO1xuXG4gICAgICB2YXIgbWF0cml4ID0gbmV3IERPTU1hdHJpeChbXG4gICAgICAgIE1hdGguY29zKHJvdGF0aW9uKSAqIHNjYWxlWCxcbiAgICAgICAgTWF0aC5zaW4ocm90YXRpb24pICogc2NhbGVYLFxuICAgICAgICAtTWF0aC5zaW4ocm90YXRpb24pICogc2NhbGVZLFxuICAgICAgICBNYXRoLmNvcyhyb3RhdGlvbikgKiBzY2FsZVksXG4gICAgICAgIGZldHRpLngsXG4gICAgICAgIGZldHRpLnlcbiAgICAgIF0pO1xuXG4gICAgICAvLyBhcHBseSB0aGUgdHJhbnNmb3JtIG1hdHJpeCBmcm9tIHRoZSBjb25mZXR0aSBzaGFwZVxuICAgICAgbWF0cml4Lm11bHRpcGx5U2VsZihuZXcgRE9NTWF0cml4KGZldHRpLnNoYXBlLm1hdHJpeCkpO1xuXG4gICAgICB2YXIgcGF0dGVybiA9IGNvbnRleHQuY3JlYXRlUGF0dGVybihiaXRtYXBNYXBwZXIudHJhbnNmb3JtKGZldHRpLnNoYXBlLmJpdG1hcCksICduby1yZXBlYXQnKTtcbiAgICAgIHBhdHRlcm4uc2V0VHJhbnNmb3JtKG1hdHJpeCk7XG5cbiAgICAgIGNvbnRleHQuZ2xvYmFsQWxwaGEgPSAoMSAtIHByb2dyZXNzKTtcbiAgICAgIGNvbnRleHQuZmlsbFN0eWxlID0gcGF0dGVybjtcbiAgICAgIGNvbnRleHQuZmlsbFJlY3QoXG4gICAgICAgIGZldHRpLnggLSAod2lkdGggLyAyKSxcbiAgICAgICAgZmV0dGkueSAtIChoZWlnaHQgLyAyKSxcbiAgICAgICAgd2lkdGgsXG4gICAgICAgIGhlaWdodFxuICAgICAgKTtcbiAgICAgIGNvbnRleHQuZ2xvYmFsQWxwaGEgPSAxO1xuICAgIH0gZWxzZSBpZiAoZmV0dGkuc2hhcGUgPT09ICdjaXJjbGUnKSB7XG4gICAgICBjb250ZXh0LmVsbGlwc2UgP1xuICAgICAgICBjb250ZXh0LmVsbGlwc2UoZmV0dGkueCwgZmV0dGkueSwgTWF0aC5hYnMoeDIgLSB4MSkgKiBmZXR0aS5vdmFsU2NhbGFyLCBNYXRoLmFicyh5MiAtIHkxKSAqIGZldHRpLm92YWxTY2FsYXIsIE1hdGguUEkgLyAxMCAqIGZldHRpLndvYmJsZSwgMCwgMiAqIE1hdGguUEkpIDpcbiAgICAgICAgZWxsaXBzZShjb250ZXh0LCBmZXR0aS54LCBmZXR0aS55LCBNYXRoLmFicyh4MiAtIHgxKSAqIGZldHRpLm92YWxTY2FsYXIsIE1hdGguYWJzKHkyIC0geTEpICogZmV0dGkub3ZhbFNjYWxhciwgTWF0aC5QSSAvIDEwICogZmV0dGkud29iYmxlLCAwLCAyICogTWF0aC5QSSk7XG4gICAgfSBlbHNlIGlmIChmZXR0aS5zaGFwZSA9PT0gJ3N0YXInKSB7XG4gICAgICB2YXIgcm90ID0gTWF0aC5QSSAvIDIgKiAzO1xuICAgICAgdmFyIGlubmVyUmFkaXVzID0gNCAqIGZldHRpLnNjYWxhcjtcbiAgICAgIHZhciBvdXRlclJhZGl1cyA9IDggKiBmZXR0aS5zY2FsYXI7XG4gICAgICB2YXIgeCA9IGZldHRpLng7XG4gICAgICB2YXIgeSA9IGZldHRpLnk7XG4gICAgICB2YXIgc3Bpa2VzID0gNTtcbiAgICAgIHZhciBzdGVwID0gTWF0aC5QSSAvIHNwaWtlcztcblxuICAgICAgd2hpbGUgKHNwaWtlcy0tKSB7XG4gICAgICAgIHggPSBmZXR0aS54ICsgTWF0aC5jb3Mocm90KSAqIG91dGVyUmFkaXVzO1xuICAgICAgICB5ID0gZmV0dGkueSArIE1hdGguc2luKHJvdCkgKiBvdXRlclJhZGl1cztcbiAgICAgICAgY29udGV4dC5saW5lVG8oeCwgeSk7XG4gICAgICAgIHJvdCArPSBzdGVwO1xuXG4gICAgICAgIHggPSBmZXR0aS54ICsgTWF0aC5jb3Mocm90KSAqIGlubmVyUmFkaXVzO1xuICAgICAgICB5ID0gZmV0dGkueSArIE1hdGguc2luKHJvdCkgKiBpbm5lclJhZGl1cztcbiAgICAgICAgY29udGV4dC5saW5lVG8oeCwgeSk7XG4gICAgICAgIHJvdCArPSBzdGVwO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBjb250ZXh0Lm1vdmVUbyhNYXRoLmZsb29yKGZldHRpLngpLCBNYXRoLmZsb29yKGZldHRpLnkpKTtcbiAgICAgIGNvbnRleHQubGluZVRvKE1hdGguZmxvb3IoZmV0dGkud29iYmxlWCksIE1hdGguZmxvb3IoeTEpKTtcbiAgICAgIGNvbnRleHQubGluZVRvKE1hdGguZmxvb3IoeDIpLCBNYXRoLmZsb29yKHkyKSk7XG4gICAgICBjb250ZXh0LmxpbmVUbyhNYXRoLmZsb29yKHgxKSwgTWF0aC5mbG9vcihmZXR0aS53b2JibGVZKSk7XG4gICAgfVxuXG4gICAgY29udGV4dC5jbG9zZVBhdGgoKTtcbiAgICBjb250ZXh0LmZpbGwoKTtcblxuICAgIHJldHVybiBmZXR0aS50aWNrIDwgZmV0dGkudG90YWxUaWNrcztcbiAgfVxuXG4gIGZ1bmN0aW9uIGFuaW1hdGUoY2FudmFzLCBmZXR0aXMsIHJlc2l6ZXIsIHNpemUsIGRvbmUpIHtcbiAgICB2YXIgYW5pbWF0aW5nRmV0dGlzID0gZmV0dGlzLnNsaWNlKCk7XG4gICAgdmFyIGNvbnRleHQgPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICB2YXIgYW5pbWF0aW9uRnJhbWU7XG4gICAgdmFyIGRlc3Ryb3k7XG5cbiAgICB2YXIgcHJvbSA9IHByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUpIHtcbiAgICAgIGZ1bmN0aW9uIG9uRG9uZSgpIHtcbiAgICAgICAgYW5pbWF0aW9uRnJhbWUgPSBkZXN0cm95ID0gbnVsbDtcblxuICAgICAgICBjb250ZXh0LmNsZWFyUmVjdCgwLCAwLCBzaXplLndpZHRoLCBzaXplLmhlaWdodCk7XG4gICAgICAgIGJpdG1hcE1hcHBlci5jbGVhcigpO1xuXG4gICAgICAgIGRvbmUoKTtcbiAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiB1cGRhdGUoKSB7XG4gICAgICAgIGlmIChpc1dvcmtlciAmJiAhKHNpemUud2lkdGggPT09IHdvcmtlclNpemUud2lkdGggJiYgc2l6ZS5oZWlnaHQgPT09IHdvcmtlclNpemUuaGVpZ2h0KSkge1xuICAgICAgICAgIHNpemUud2lkdGggPSBjYW52YXMud2lkdGggPSB3b3JrZXJTaXplLndpZHRoO1xuICAgICAgICAgIHNpemUuaGVpZ2h0ID0gY2FudmFzLmhlaWdodCA9IHdvcmtlclNpemUuaGVpZ2h0O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFzaXplLndpZHRoICYmICFzaXplLmhlaWdodCkge1xuICAgICAgICAgIHJlc2l6ZXIoY2FudmFzKTtcbiAgICAgICAgICBzaXplLndpZHRoID0gY2FudmFzLndpZHRoO1xuICAgICAgICAgIHNpemUuaGVpZ2h0ID0gY2FudmFzLmhlaWdodDtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnRleHQuY2xlYXJSZWN0KDAsIDAsIHNpemUud2lkdGgsIHNpemUuaGVpZ2h0KTtcblxuICAgICAgICBhbmltYXRpbmdGZXR0aXMgPSBhbmltYXRpbmdGZXR0aXMuZmlsdGVyKGZ1bmN0aW9uIChmZXR0aSkge1xuICAgICAgICAgIHJldHVybiB1cGRhdGVGZXR0aShjb250ZXh0LCBmZXR0aSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmIChhbmltYXRpbmdGZXR0aXMubGVuZ3RoKSB7XG4gICAgICAgICAgYW5pbWF0aW9uRnJhbWUgPSByYWYuZnJhbWUodXBkYXRlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBvbkRvbmUoKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBhbmltYXRpb25GcmFtZSA9IHJhZi5mcmFtZSh1cGRhdGUpO1xuICAgICAgZGVzdHJveSA9IG9uRG9uZTtcbiAgICB9KTtcblxuICAgIHJldHVybiB7XG4gICAgICBhZGRGZXR0aXM6IGZ1bmN0aW9uIChmZXR0aXMpIHtcbiAgICAgICAgYW5pbWF0aW5nRmV0dGlzID0gYW5pbWF0aW5nRmV0dGlzLmNvbmNhdChmZXR0aXMpO1xuXG4gICAgICAgIHJldHVybiBwcm9tO1xuICAgICAgfSxcbiAgICAgIGNhbnZhczogY2FudmFzLFxuICAgICAgcHJvbWlzZTogcHJvbSxcbiAgICAgIHJlc2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmIChhbmltYXRpb25GcmFtZSkge1xuICAgICAgICAgIHJhZi5jYW5jZWwoYW5pbWF0aW9uRnJhbWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGRlc3Ryb3kpIHtcbiAgICAgICAgICBkZXN0cm95KCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICB9XG5cbiAgZnVuY3Rpb24gY29uZmV0dGlDYW5ub24oY2FudmFzLCBnbG9iYWxPcHRzKSB7XG4gICAgdmFyIGlzTGliQ2FudmFzID0gIWNhbnZhcztcbiAgICB2YXIgYWxsb3dSZXNpemUgPSAhIXByb3AoZ2xvYmFsT3B0cyB8fCB7fSwgJ3Jlc2l6ZScpO1xuICAgIHZhciBoYXNSZXNpemVFdmVudFJlZ2lzdGVyZWQgPSBmYWxzZTtcbiAgICB2YXIgZ2xvYmFsRGlzYWJsZUZvclJlZHVjZWRNb3Rpb24gPSBwcm9wKGdsb2JhbE9wdHMsICdkaXNhYmxlRm9yUmVkdWNlZE1vdGlvbicsIEJvb2xlYW4pO1xuICAgIHZhciBzaG91bGRVc2VXb3JrZXIgPSBjYW5Vc2VXb3JrZXIgJiYgISFwcm9wKGdsb2JhbE9wdHMgfHwge30sICd1c2VXb3JrZXInKTtcbiAgICB2YXIgd29ya2VyID0gc2hvdWxkVXNlV29ya2VyID8gZ2V0V29ya2VyKCkgOiBudWxsO1xuICAgIHZhciByZXNpemVyID0gaXNMaWJDYW52YXMgPyBzZXRDYW52YXNXaW5kb3dTaXplIDogc2V0Q2FudmFzUmVjdFNpemU7XG4gICAgdmFyIGluaXRpYWxpemVkID0gKGNhbnZhcyAmJiB3b3JrZXIpID8gISFjYW52YXMuX19jb25mZXR0aV9pbml0aWFsaXplZCA6IGZhbHNlO1xuICAgIHZhciBwcmVmZXJMZXNzTW90aW9uID0gdHlwZW9mIG1hdGNoTWVkaWEgPT09ICdmdW5jdGlvbicgJiYgbWF0Y2hNZWRpYSgnKHByZWZlcnMtcmVkdWNlZC1tb3Rpb24pJykubWF0Y2hlcztcbiAgICB2YXIgYW5pbWF0aW9uT2JqO1xuXG4gICAgZnVuY3Rpb24gZmlyZUxvY2FsKG9wdGlvbnMsIHNpemUsIGRvbmUpIHtcbiAgICAgIHZhciBwYXJ0aWNsZUNvdW50ID0gcHJvcChvcHRpb25zLCAncGFydGljbGVDb3VudCcsIG9ubHlQb3NpdGl2ZUludCk7XG4gICAgICB2YXIgYW5nbGUgPSBwcm9wKG9wdGlvbnMsICdhbmdsZScsIE51bWJlcik7XG4gICAgICB2YXIgc3ByZWFkID0gcHJvcChvcHRpb25zLCAnc3ByZWFkJywgTnVtYmVyKTtcbiAgICAgIHZhciBzdGFydFZlbG9jaXR5ID0gcHJvcChvcHRpb25zLCAnc3RhcnRWZWxvY2l0eScsIE51bWJlcik7XG4gICAgICB2YXIgZGVjYXkgPSBwcm9wKG9wdGlvbnMsICdkZWNheScsIE51bWJlcik7XG4gICAgICB2YXIgZ3Jhdml0eSA9IHByb3Aob3B0aW9ucywgJ2dyYXZpdHknLCBOdW1iZXIpO1xuICAgICAgdmFyIGRyaWZ0ID0gcHJvcChvcHRpb25zLCAnZHJpZnQnLCBOdW1iZXIpO1xuICAgICAgdmFyIGNvbG9ycyA9IHByb3Aob3B0aW9ucywgJ2NvbG9ycycsIGNvbG9yc1RvUmdiKTtcbiAgICAgIHZhciB0aWNrcyA9IHByb3Aob3B0aW9ucywgJ3RpY2tzJywgTnVtYmVyKTtcbiAgICAgIHZhciBzaGFwZXMgPSBwcm9wKG9wdGlvbnMsICdzaGFwZXMnKTtcbiAgICAgIHZhciBzY2FsYXIgPSBwcm9wKG9wdGlvbnMsICdzY2FsYXInKTtcbiAgICAgIHZhciBmbGF0ID0gISFwcm9wKG9wdGlvbnMsICdmbGF0Jyk7XG4gICAgICB2YXIgb3JpZ2luID0gZ2V0T3JpZ2luKG9wdGlvbnMpO1xuXG4gICAgICB2YXIgdGVtcCA9IHBhcnRpY2xlQ291bnQ7XG4gICAgICB2YXIgZmV0dGlzID0gW107XG5cbiAgICAgIHZhciBzdGFydFggPSBjYW52YXMud2lkdGggKiBvcmlnaW4ueDtcbiAgICAgIHZhciBzdGFydFkgPSBjYW52YXMuaGVpZ2h0ICogb3JpZ2luLnk7XG5cbiAgICAgIHdoaWxlICh0ZW1wLS0pIHtcbiAgICAgICAgZmV0dGlzLnB1c2goXG4gICAgICAgICAgcmFuZG9tUGh5c2ljcyh7XG4gICAgICAgICAgICB4OiBzdGFydFgsXG4gICAgICAgICAgICB5OiBzdGFydFksXG4gICAgICAgICAgICBhbmdsZTogYW5nbGUsXG4gICAgICAgICAgICBzcHJlYWQ6IHNwcmVhZCxcbiAgICAgICAgICAgIHN0YXJ0VmVsb2NpdHk6IHN0YXJ0VmVsb2NpdHksXG4gICAgICAgICAgICBjb2xvcjogY29sb3JzW3RlbXAgJSBjb2xvcnMubGVuZ3RoXSxcbiAgICAgICAgICAgIHNoYXBlOiBzaGFwZXNbcmFuZG9tSW50KDAsIHNoYXBlcy5sZW5ndGgpXSxcbiAgICAgICAgICAgIHRpY2tzOiB0aWNrcyxcbiAgICAgICAgICAgIGRlY2F5OiBkZWNheSxcbiAgICAgICAgICAgIGdyYXZpdHk6IGdyYXZpdHksXG4gICAgICAgICAgICBkcmlmdDogZHJpZnQsXG4gICAgICAgICAgICBzY2FsYXI6IHNjYWxhcixcbiAgICAgICAgICAgIGZsYXQ6IGZsYXRcbiAgICAgICAgICB9KVxuICAgICAgICApO1xuICAgICAgfVxuXG4gICAgICAvLyBpZiB3ZSBoYXZlIGEgcHJldmlvdXMgY2FudmFzIGFscmVhZHkgYW5pbWF0aW5nLFxuICAgICAgLy8gYWRkIHRvIGl0XG4gICAgICBpZiAoYW5pbWF0aW9uT2JqKSB7XG4gICAgICAgIHJldHVybiBhbmltYXRpb25PYmouYWRkRmV0dGlzKGZldHRpcyk7XG4gICAgICB9XG5cbiAgICAgIGFuaW1hdGlvbk9iaiA9IGFuaW1hdGUoY2FudmFzLCBmZXR0aXMsIHJlc2l6ZXIsIHNpemUgLCBkb25lKTtcblxuICAgICAgcmV0dXJuIGFuaW1hdGlvbk9iai5wcm9taXNlO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGZpcmUob3B0aW9ucykge1xuICAgICAgdmFyIGRpc2FibGVGb3JSZWR1Y2VkTW90aW9uID0gZ2xvYmFsRGlzYWJsZUZvclJlZHVjZWRNb3Rpb24gfHwgcHJvcChvcHRpb25zLCAnZGlzYWJsZUZvclJlZHVjZWRNb3Rpb24nLCBCb29sZWFuKTtcbiAgICAgIHZhciB6SW5kZXggPSBwcm9wKG9wdGlvbnMsICd6SW5kZXgnLCBOdW1iZXIpO1xuXG4gICAgICBpZiAoZGlzYWJsZUZvclJlZHVjZWRNb3Rpb24gJiYgcHJlZmVyTGVzc01vdGlvbikge1xuICAgICAgICByZXR1cm4gcHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSkge1xuICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChpc0xpYkNhbnZhcyAmJiBhbmltYXRpb25PYmopIHtcbiAgICAgICAgLy8gdXNlIGV4aXN0aW5nIGNhbnZhcyBmcm9tIGluLXByb2dyZXNzIGFuaW1hdGlvblxuICAgICAgICBjYW52YXMgPSBhbmltYXRpb25PYmouY2FudmFzO1xuICAgICAgfSBlbHNlIGlmIChpc0xpYkNhbnZhcyAmJiAhY2FudmFzKSB7XG4gICAgICAgIC8vIGNyZWF0ZSBhbmQgaW5pdGlhbGl6ZSBhIG5ldyBjYW52YXNcbiAgICAgICAgY2FudmFzID0gZ2V0Q2FudmFzKHpJbmRleCk7XG4gICAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoY2FudmFzKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGFsbG93UmVzaXplICYmICFpbml0aWFsaXplZCkge1xuICAgICAgICAvLyBpbml0aWFsaXplIHRoZSBzaXplIG9mIGEgdXNlci1zdXBwbGllZCBjYW52YXNcbiAgICAgICAgcmVzaXplcihjYW52YXMpO1xuICAgICAgfVxuXG4gICAgICB2YXIgc2l6ZSA9IHtcbiAgICAgICAgd2lkdGg6IGNhbnZhcy53aWR0aCxcbiAgICAgICAgaGVpZ2h0OiBjYW52YXMuaGVpZ2h0XG4gICAgICB9O1xuXG4gICAgICBpZiAod29ya2VyICYmICFpbml0aWFsaXplZCkge1xuICAgICAgICB3b3JrZXIuaW5pdChjYW52YXMpO1xuICAgICAgfVxuXG4gICAgICBpbml0aWFsaXplZCA9IHRydWU7XG5cbiAgICAgIGlmICh3b3JrZXIpIHtcbiAgICAgICAgY2FudmFzLl9fY29uZmV0dGlfaW5pdGlhbGl6ZWQgPSB0cnVlO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBvblJlc2l6ZSgpIHtcbiAgICAgICAgaWYgKHdvcmtlcikge1xuICAgICAgICAgIC8vIFRPRE8gdGhpcyByZWFsbHkgc2hvdWxkbid0IGJlIGltbWVkaWF0ZSwgYmVjYXVzZSBpdCBpcyBleHBlbnNpdmVcbiAgICAgICAgICB2YXIgb2JqID0ge1xuICAgICAgICAgICAgZ2V0Qm91bmRpbmdDbGllbnRSZWN0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIGlmICghaXNMaWJDYW52YXMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY2FudmFzLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfTtcblxuICAgICAgICAgIHJlc2l6ZXIob2JqKTtcblxuICAgICAgICAgIHdvcmtlci5wb3N0TWVzc2FnZSh7XG4gICAgICAgICAgICByZXNpemU6IHtcbiAgICAgICAgICAgICAgd2lkdGg6IG9iai53aWR0aCxcbiAgICAgICAgICAgICAgaGVpZ2h0OiBvYmouaGVpZ2h0XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gZG9uJ3QgYWN0dWFsbHkgcXVlcnkgdGhlIHNpemUgaGVyZSwgc2luY2UgdGhpc1xuICAgICAgICAvLyBjYW4gZXhlY3V0ZSBmcmVxdWVudGx5IGFuZCByYXBpZGx5XG4gICAgICAgIHNpemUud2lkdGggPSBzaXplLmhlaWdodCA9IG51bGw7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGRvbmUoKSB7XG4gICAgICAgIGFuaW1hdGlvbk9iaiA9IG51bGw7XG5cbiAgICAgICAgaWYgKGFsbG93UmVzaXplKSB7XG4gICAgICAgICAgaGFzUmVzaXplRXZlbnRSZWdpc3RlcmVkID0gZmFsc2U7XG4gICAgICAgICAgZ2xvYmFsLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIG9uUmVzaXplKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpc0xpYkNhbnZhcyAmJiBjYW52YXMpIHtcbiAgICAgICAgICBpZiAoZG9jdW1lbnQuYm9keS5jb250YWlucyhjYW52YXMpKSB7XG4gICAgICAgICAgICBkb2N1bWVudC5ib2R5LnJlbW92ZUNoaWxkKGNhbnZhcyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNhbnZhcyA9IG51bGw7XG4gICAgICAgICAgaW5pdGlhbGl6ZWQgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoYWxsb3dSZXNpemUgJiYgIWhhc1Jlc2l6ZUV2ZW50UmVnaXN0ZXJlZCkge1xuICAgICAgICBoYXNSZXNpemVFdmVudFJlZ2lzdGVyZWQgPSB0cnVlO1xuICAgICAgICBnbG9iYWwuYWRkRXZlbnRMaXN0ZW5lcigncmVzaXplJywgb25SZXNpemUsIGZhbHNlKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHdvcmtlcikge1xuICAgICAgICByZXR1cm4gd29ya2VyLmZpcmUob3B0aW9ucywgc2l6ZSwgZG9uZSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBmaXJlTG9jYWwob3B0aW9ucywgc2l6ZSwgZG9uZSk7XG4gICAgfVxuXG4gICAgZmlyZS5yZXNldCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmICh3b3JrZXIpIHtcbiAgICAgICAgd29ya2VyLnJlc2V0KCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChhbmltYXRpb25PYmopIHtcbiAgICAgICAgYW5pbWF0aW9uT2JqLnJlc2V0KCk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIHJldHVybiBmaXJlO1xuICB9XG5cbiAgLy8gTWFrZSBkZWZhdWx0IGV4cG9ydCBsYXp5IHRvIGRlZmVyIHdvcmtlciBjcmVhdGlvbiB1bnRpbCBjYWxsZWQuXG4gIHZhciBkZWZhdWx0RmlyZTtcbiAgZnVuY3Rpb24gZ2V0RGVmYXVsdEZpcmUoKSB7XG4gICAgaWYgKCFkZWZhdWx0RmlyZSkge1xuICAgICAgZGVmYXVsdEZpcmUgPSBjb25mZXR0aUNhbm5vbihudWxsLCB7IHVzZVdvcmtlcjogdHJ1ZSwgcmVzaXplOiB0cnVlIH0pO1xuICAgIH1cbiAgICByZXR1cm4gZGVmYXVsdEZpcmU7XG4gIH1cblxuICBmdW5jdGlvbiB0cmFuc2Zvcm1QYXRoMkQocGF0aFN0cmluZywgcGF0aE1hdHJpeCwgeCwgeSwgc2NhbGVYLCBzY2FsZVksIHJvdGF0aW9uKSB7XG4gICAgdmFyIHBhdGgyZCA9IG5ldyBQYXRoMkQocGF0aFN0cmluZyk7XG5cbiAgICB2YXIgdDEgPSBuZXcgUGF0aDJEKCk7XG4gICAgdDEuYWRkUGF0aChwYXRoMmQsIG5ldyBET01NYXRyaXgocGF0aE1hdHJpeCkpO1xuXG4gICAgdmFyIHQyID0gbmV3IFBhdGgyRCgpO1xuICAgIC8vIHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvRE9NTWF0cml4L0RPTU1hdHJpeFxuICAgIHQyLmFkZFBhdGgodDEsIG5ldyBET01NYXRyaXgoW1xuICAgICAgTWF0aC5jb3Mocm90YXRpb24pICogc2NhbGVYLFxuICAgICAgTWF0aC5zaW4ocm90YXRpb24pICogc2NhbGVYLFxuICAgICAgLU1hdGguc2luKHJvdGF0aW9uKSAqIHNjYWxlWSxcbiAgICAgIE1hdGguY29zKHJvdGF0aW9uKSAqIHNjYWxlWSxcbiAgICAgIHgsXG4gICAgICB5XG4gICAgXSkpO1xuXG4gICAgcmV0dXJuIHQyO1xuICB9XG5cbiAgZnVuY3Rpb24gc2hhcGVGcm9tUGF0aChwYXRoRGF0YSkge1xuICAgIGlmICghY2FuVXNlUGF0aHMpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcigncGF0aCBjb25mZXR0aSBhcmUgbm90IHN1cHBvcnRlZCBpbiB0aGlzIGJyb3dzZXInKTtcbiAgICB9XG5cbiAgICB2YXIgcGF0aCwgbWF0cml4O1xuXG4gICAgaWYgKHR5cGVvZiBwYXRoRGF0YSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHBhdGggPSBwYXRoRGF0YTtcbiAgICB9IGVsc2Uge1xuICAgICAgcGF0aCA9IHBhdGhEYXRhLnBhdGg7XG4gICAgICBtYXRyaXggPSBwYXRoRGF0YS5tYXRyaXg7XG4gICAgfVxuXG4gICAgdmFyIHBhdGgyZCA9IG5ldyBQYXRoMkQocGF0aCk7XG4gICAgdmFyIHRlbXBDYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcbiAgICB2YXIgdGVtcEN0eCA9IHRlbXBDYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcblxuICAgIGlmICghbWF0cml4KSB7XG4gICAgICAvLyBhdHRlbXB0IHRvIGZpZ3VyZSBvdXQgdGhlIHdpZHRoIG9mIHRoZSBwYXRoLCB1cCB0byAxMDAweDEwMDBcbiAgICAgIHZhciBtYXhTaXplID0gMTAwMDtcbiAgICAgIHZhciBtaW5YID0gbWF4U2l6ZTtcbiAgICAgIHZhciBtaW5ZID0gbWF4U2l6ZTtcbiAgICAgIHZhciBtYXhYID0gMDtcbiAgICAgIHZhciBtYXhZID0gMDtcbiAgICAgIHZhciB3aWR0aCwgaGVpZ2h0O1xuXG4gICAgICAvLyBkbyBzb21lIGxpbmUgc2tpcHBpbmcuLi4gdGhpcyBpcyBmYXN0ZXIgdGhhbiBjaGVja2luZ1xuICAgICAgLy8gZXZlcnkgcGl4ZWwgYW5kIHdpbGwgYmUgbW9zdGx5IHN0aWxsIGNvcnJlY3RcbiAgICAgIGZvciAodmFyIHggPSAwOyB4IDwgbWF4U2l6ZTsgeCArPSAyKSB7XG4gICAgICAgIGZvciAodmFyIHkgPSAwOyB5IDwgbWF4U2l6ZTsgeSArPSAyKSB7XG4gICAgICAgICAgaWYgKHRlbXBDdHguaXNQb2ludEluUGF0aChwYXRoMmQsIHgsIHksICdub256ZXJvJykpIHtcbiAgICAgICAgICAgIG1pblggPSBNYXRoLm1pbihtaW5YLCB4KTtcbiAgICAgICAgICAgIG1pblkgPSBNYXRoLm1pbihtaW5ZLCB5KTtcbiAgICAgICAgICAgIG1heFggPSBNYXRoLm1heChtYXhYLCB4KTtcbiAgICAgICAgICAgIG1heFkgPSBNYXRoLm1heChtYXhZLCB5KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgd2lkdGggPSBtYXhYIC0gbWluWDtcbiAgICAgIGhlaWdodCA9IG1heFkgLSBtaW5ZO1xuXG4gICAgICB2YXIgbWF4RGVzaXJlZFNpemUgPSAxMDtcbiAgICAgIHZhciBzY2FsZSA9IE1hdGgubWluKG1heERlc2lyZWRTaXplL3dpZHRoLCBtYXhEZXNpcmVkU2l6ZS9oZWlnaHQpO1xuXG4gICAgICBtYXRyaXggPSBbXG4gICAgICAgIHNjYWxlLCAwLCAwLCBzY2FsZSxcbiAgICAgICAgLU1hdGgucm91bmQoKHdpZHRoLzIpICsgbWluWCkgKiBzY2FsZSxcbiAgICAgICAgLU1hdGgucm91bmQoKGhlaWdodC8yKSArIG1pblkpICogc2NhbGVcbiAgICAgIF07XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6ICdwYXRoJyxcbiAgICAgIHBhdGg6IHBhdGgsXG4gICAgICBtYXRyaXg6IG1hdHJpeFxuICAgIH07XG4gIH1cblxuICBmdW5jdGlvbiBzaGFwZUZyb21UZXh0KHRleHREYXRhKSB7XG4gICAgdmFyIHRleHQsXG4gICAgICAgIHNjYWxhciA9IDEsXG4gICAgICAgIGNvbG9yID0gJyMwMDAwMDAnLFxuICAgICAgICAvLyBzZWUgaHR0cHM6Ly9ub2xhbmxhd3Nvbi5jb20vMjAyMi8wNC8wOC90aGUtc3RydWdnbGUtb2YtdXNpbmctbmF0aXZlLWVtb2ppLW9uLXRoZS13ZWIvXG4gICAgICAgIGZvbnRGYW1pbHkgPSAnXCJBcHBsZSBDb2xvciBFbW9qaVwiLCBcIlNlZ29lIFVJIEVtb2ppXCIsIFwiU2Vnb2UgVUkgU3ltYm9sXCIsIFwiTm90byBDb2xvciBFbW9qaVwiLCBcIkVtb2ppT25lIENvbG9yXCIsIFwiQW5kcm9pZCBFbW9qaVwiLCBcIlR3ZW1vamkgTW96aWxsYVwiLCBcInN5c3RlbSBlbW9qaVwiLCBzYW5zLXNlcmlmJztcblxuICAgIGlmICh0eXBlb2YgdGV4dERhdGEgPT09ICdzdHJpbmcnKSB7XG4gICAgICB0ZXh0ID0gdGV4dERhdGE7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRleHQgPSB0ZXh0RGF0YS50ZXh0O1xuICAgICAgc2NhbGFyID0gJ3NjYWxhcicgaW4gdGV4dERhdGEgPyB0ZXh0RGF0YS5zY2FsYXIgOiBzY2FsYXI7XG4gICAgICBmb250RmFtaWx5ID0gJ2ZvbnRGYW1pbHknIGluIHRleHREYXRhID8gdGV4dERhdGEuZm9udEZhbWlseSA6IGZvbnRGYW1pbHk7XG4gICAgICBjb2xvciA9ICdjb2xvcicgaW4gdGV4dERhdGEgPyB0ZXh0RGF0YS5jb2xvciA6IGNvbG9yO1xuICAgIH1cblxuICAgIC8vIGFsbCBvdGhlciBjb25mZXR0aSBhcmUgMTAgcGl4ZWxzLFxuICAgIC8vIHNvIHRoaXMgcGl4ZWwgc2l6ZSBpcyB0aGUgZGUtZmFjdG8gMTAwJSBzY2FsZSBjb25mZXR0aVxuICAgIHZhciBmb250U2l6ZSA9IDEwICogc2NhbGFyO1xuICAgIHZhciBmb250ID0gJycgKyBmb250U2l6ZSArICdweCAnICsgZm9udEZhbWlseTtcblxuICAgIHZhciBjYW52YXMgPSBuZXcgT2Zmc2NyZWVuQ2FudmFzKGZvbnRTaXplLCBmb250U2l6ZSk7XG4gICAgdmFyIGN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuXG4gICAgY3R4LmZvbnQgPSBmb250O1xuICAgIHZhciBzaXplID0gY3R4Lm1lYXN1cmVUZXh0KHRleHQpO1xuICAgIHZhciB3aWR0aCA9IE1hdGguY2VpbChzaXplLmFjdHVhbEJvdW5kaW5nQm94UmlnaHQgKyBzaXplLmFjdHVhbEJvdW5kaW5nQm94TGVmdCk7XG4gICAgdmFyIGhlaWdodCA9IE1hdGguY2VpbChzaXplLmFjdHVhbEJvdW5kaW5nQm94QXNjZW50ICsgc2l6ZS5hY3R1YWxCb3VuZGluZ0JveERlc2NlbnQpO1xuXG4gICAgdmFyIHBhZGRpbmcgPSAyO1xuICAgIHZhciB4ID0gc2l6ZS5hY3R1YWxCb3VuZGluZ0JveExlZnQgKyBwYWRkaW5nO1xuICAgIHZhciB5ID0gc2l6ZS5hY3R1YWxCb3VuZGluZ0JveEFzY2VudCArIHBhZGRpbmc7XG4gICAgd2lkdGggKz0gcGFkZGluZyArIHBhZGRpbmc7XG4gICAgaGVpZ2h0ICs9IHBhZGRpbmcgKyBwYWRkaW5nO1xuXG4gICAgY2FudmFzID0gbmV3IE9mZnNjcmVlbkNhbnZhcyh3aWR0aCwgaGVpZ2h0KTtcbiAgICBjdHggPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICBjdHguZm9udCA9IGZvbnQ7XG4gICAgY3R4LmZpbGxTdHlsZSA9IGNvbG9yO1xuXG4gICAgY3R4LmZpbGxUZXh0KHRleHQsIHgsIHkpO1xuXG4gICAgdmFyIHNjYWxlID0gMSAvIHNjYWxhcjtcblxuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiAnYml0bWFwJyxcbiAgICAgIC8vIFRPRE8gdGhlc2UgcHJvYmFibHkgbmVlZCB0byBiZSB0cmFuc2ZlcmVkIGZvciB3b3JrZXJzXG4gICAgICBiaXRtYXA6IGNhbnZhcy50cmFuc2ZlclRvSW1hZ2VCaXRtYXAoKSxcbiAgICAgIG1hdHJpeDogW3NjYWxlLCAwLCAwLCBzY2FsZSwgLXdpZHRoICogc2NhbGUgLyAyLCAtaGVpZ2h0ICogc2NhbGUgLyAyXVxuICAgIH07XG4gIH1cblxuICBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBnZXREZWZhdWx0RmlyZSgpLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH07XG4gIG1vZHVsZS5leHBvcnRzLnJlc2V0ID0gZnVuY3Rpb24oKSB7XG4gICAgZ2V0RGVmYXVsdEZpcmUoKS5yZXNldCgpO1xuICB9O1xuICBtb2R1bGUuZXhwb3J0cy5jcmVhdGUgPSBjb25mZXR0aUNhbm5vbjtcbiAgbW9kdWxlLmV4cG9ydHMuc2hhcGVGcm9tUGF0aCA9IHNoYXBlRnJvbVBhdGg7XG4gIG1vZHVsZS5leHBvcnRzLnNoYXBlRnJvbVRleHQgPSBzaGFwZUZyb21UZXh0O1xufSgoZnVuY3Rpb24gKCkge1xuICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICByZXR1cm4gd2luZG93O1xuICB9XG5cbiAgaWYgKHR5cGVvZiBzZWxmICE9PSAndW5kZWZpbmVkJykge1xuICAgIHJldHVybiBzZWxmO1xuICB9XG5cbiAgcmV0dXJuIHRoaXMgfHwge307XG59KSgpLCBtb2R1bGUsIGZhbHNlKSk7XG5cbi8vIGVuZCBzb3VyY2UgY29udGVudFxuXG5leHBvcnQgZGVmYXVsdCBtb2R1bGUuZXhwb3J0cztcbmV4cG9ydCB2YXIgY3JlYXRlID0gbW9kdWxlLmV4cG9ydHMuY3JlYXRlO1xuIl0sIm5hbWVzIjpbIm1vZHVsZSIsIm1haW4iLCJnbG9iYWwiLCJpc1dvcmtlciIsIndvcmtlclNpemUiLCJjYW5Vc2VXb3JrZXIiLCJXb3JrZXIiLCJCbG9iIiwiUHJvbWlzZSIsIk9mZnNjcmVlbkNhbnZhcyIsIk9mZnNjcmVlbkNhbnZhc1JlbmRlcmluZ0NvbnRleHQyRCIsIkhUTUxDYW52YXNFbGVtZW50IiwicHJvdG90eXBlIiwidHJhbnNmZXJDb250cm9sVG9PZmZzY3JlZW4iLCJVUkwiLCJjcmVhdGVPYmplY3RVUkwiLCJjYW5Vc2VQYXRocyIsIlBhdGgyRCIsIkRPTU1hdHJpeCIsImNhbkRyYXdCaXRtYXAiLCJjYW52YXMiLCJjdHgiLCJnZXRDb250ZXh0IiwiZmlsbFJlY3QiLCJiaXRtYXAiLCJ0cmFuc2ZlclRvSW1hZ2VCaXRtYXAiLCJjcmVhdGVQYXR0ZXJuIiwiZSIsIm5vb3AiLCJwcm9taXNlIiwiZnVuYyIsIk1vZHVsZVByb21pc2UiLCJleHBvcnRzIiwiUHJvbSIsImJpdG1hcE1hcHBlciIsInNraXBUcmFuc2Zvcm0iLCJtYXAiLCJ0cmFuc2Zvcm0iLCJoYXMiLCJnZXQiLCJ3aWR0aCIsImhlaWdodCIsImRyYXdJbWFnZSIsInNldCIsImNsZWFyIiwiTWFwIiwicmFmIiwiVElNRSIsIk1hdGgiLCJmbG9vciIsImZyYW1lIiwiY2FuY2VsIiwiZnJhbWVzIiwibGFzdEZyYW1lVGltZSIsInJlcXVlc3RBbmltYXRpb25GcmFtZSIsImNhbmNlbEFuaW1hdGlvbkZyYW1lIiwiY2IiLCJpZCIsInJhbmRvbSIsIm9uRnJhbWUiLCJ0aW1lIiwic2V0VGltZW91dCIsInRpbWVyIiwiY2xlYXJUaW1lb3V0IiwiZ2V0V29ya2VyIiwid29ya2VyIiwicHJvbSIsInJlc29sdmVzIiwiZGVjb3JhdGUiLCJleGVjdXRlIiwib3B0aW9ucyIsImNhbGxiYWNrIiwicG9zdE1lc3NhZ2UiLCJpbml0IiwiaW5pdFdvcmtlciIsIm9mZnNjcmVlbiIsImZpcmUiLCJmaXJlV29ya2VyIiwic2l6ZSIsImRvbmUiLCJ0b1N0cmluZyIsInNsaWNlIiwicmVzb2x2ZSIsIndvcmtlckRvbmUiLCJtc2ciLCJkYXRhIiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsImFkZEV2ZW50TGlzdGVuZXIiLCJiaW5kIiwicmVzZXQiLCJyZXNldFdvcmtlciIsImNvZGUiLCJqb2luIiwiY29uc29sZSIsIndhcm4iLCJkZWZhdWx0cyIsInBhcnRpY2xlQ291bnQiLCJhbmdsZSIsInNwcmVhZCIsInN0YXJ0VmVsb2NpdHkiLCJkZWNheSIsImdyYXZpdHkiLCJkcmlmdCIsInRpY2tzIiwieCIsInkiLCJzaGFwZXMiLCJ6SW5kZXgiLCJjb2xvcnMiLCJkaXNhYmxlRm9yUmVkdWNlZE1vdGlvbiIsInNjYWxhciIsImNvbnZlcnQiLCJ2YWwiLCJpc09rIiwidW5kZWZpbmVkIiwicHJvcCIsIm5hbWUiLCJvbmx5UG9zaXRpdmVJbnQiLCJudW1iZXIiLCJyYW5kb21JbnQiLCJtaW4iLCJtYXgiLCJ0b0RlY2ltYWwiLCJzdHIiLCJwYXJzZUludCIsImNvbG9yc1RvUmdiIiwiaGV4VG9SZ2IiLCJTdHJpbmciLCJyZXBsYWNlIiwibGVuZ3RoIiwiciIsInN1YnN0cmluZyIsImciLCJiIiwiZ2V0T3JpZ2luIiwib3JpZ2luIiwiT2JqZWN0IiwiTnVtYmVyIiwic2V0Q2FudmFzV2luZG93U2l6ZSIsImRvY3VtZW50IiwiZG9jdW1lbnRFbGVtZW50IiwiY2xpZW50V2lkdGgiLCJjbGllbnRIZWlnaHQiLCJzZXRDYW52YXNSZWN0U2l6ZSIsInJlY3QiLCJnZXRCb3VuZGluZ0NsaWVudFJlY3QiLCJnZXRDYW52YXMiLCJjcmVhdGVFbGVtZW50Iiwic3R5bGUiLCJwb3NpdGlvbiIsInRvcCIsImxlZnQiLCJwb2ludGVyRXZlbnRzIiwiZWxsaXBzZSIsImNvbnRleHQiLCJyYWRpdXNYIiwicmFkaXVzWSIsInJvdGF0aW9uIiwic3RhcnRBbmdsZSIsImVuZEFuZ2xlIiwiYW50aUNsb2Nrd2lzZSIsInNhdmUiLCJ0cmFuc2xhdGUiLCJyb3RhdGUiLCJzY2FsZSIsImFyYyIsInJlc3RvcmUiLCJyYW5kb21QaHlzaWNzIiwib3B0cyIsInJhZEFuZ2xlIiwiUEkiLCJyYWRTcHJlYWQiLCJ3b2JibGUiLCJ3b2JibGVTcGVlZCIsInZlbG9jaXR5IiwiYW5nbGUyRCIsInRpbHRBbmdsZSIsImNvbG9yIiwic2hhcGUiLCJ0aWNrIiwidG90YWxUaWNrcyIsInRpbHRTaW4iLCJ0aWx0Q29zIiwid29iYmxlWCIsIndvYmJsZVkiLCJvdmFsU2NhbGFyIiwiZmxhdCIsInVwZGF0ZUZldHRpIiwiZmV0dGkiLCJjb3MiLCJzaW4iLCJwcm9ncmVzcyIsIngxIiwieTEiLCJ4MiIsInkyIiwiZmlsbFN0eWxlIiwiYmVnaW5QYXRoIiwidHlwZSIsInBhdGgiLCJBcnJheSIsImlzQXJyYXkiLCJtYXRyaXgiLCJmaWxsIiwidHJhbnNmb3JtUGF0aDJEIiwiYWJzIiwic2NhbGVYIiwic2NhbGVZIiwibXVsdGlwbHlTZWxmIiwicGF0dGVybiIsInNldFRyYW5zZm9ybSIsImdsb2JhbEFscGhhIiwicm90IiwiaW5uZXJSYWRpdXMiLCJvdXRlclJhZGl1cyIsInNwaWtlcyIsInN0ZXAiLCJsaW5lVG8iLCJtb3ZlVG8iLCJjbG9zZVBhdGgiLCJhbmltYXRlIiwiZmV0dGlzIiwicmVzaXplciIsImFuaW1hdGluZ0ZldHRpcyIsImFuaW1hdGlvbkZyYW1lIiwiZGVzdHJveSIsIm9uRG9uZSIsImNsZWFyUmVjdCIsInVwZGF0ZSIsImZpbHRlciIsImFkZEZldHRpcyIsImNvbmNhdCIsImNvbmZldHRpQ2Fubm9uIiwiZ2xvYmFsT3B0cyIsImlzTGliQ2FudmFzIiwiYWxsb3dSZXNpemUiLCJoYXNSZXNpemVFdmVudFJlZ2lzdGVyZWQiLCJnbG9iYWxEaXNhYmxlRm9yUmVkdWNlZE1vdGlvbiIsIkJvb2xlYW4iLCJzaG91bGRVc2VXb3JrZXIiLCJpbml0aWFsaXplZCIsIl9fY29uZmV0dGlfaW5pdGlhbGl6ZWQiLCJwcmVmZXJMZXNzTW90aW9uIiwibWF0Y2hNZWRpYSIsIm1hdGNoZXMiLCJhbmltYXRpb25PYmoiLCJmaXJlTG9jYWwiLCJ0ZW1wIiwic3RhcnRYIiwic3RhcnRZIiwicHVzaCIsImJvZHkiLCJhcHBlbmRDaGlsZCIsIm9uUmVzaXplIiwib2JqIiwicmVzaXplIiwiY29udGFpbnMiLCJyZW1vdmVDaGlsZCIsImRlZmF1bHRGaXJlIiwiZ2V0RGVmYXVsdEZpcmUiLCJ1c2VXb3JrZXIiLCJwYXRoU3RyaW5nIiwicGF0aE1hdHJpeCIsInBhdGgyZCIsInQxIiwiYWRkUGF0aCIsInQyIiwic2hhcGVGcm9tUGF0aCIsInBhdGhEYXRhIiwiRXJyb3IiLCJ0ZW1wQ2FudmFzIiwidGVtcEN0eCIsIm1heFNpemUiLCJtaW5YIiwibWluWSIsIm1heFgiLCJtYXhZIiwiaXNQb2ludEluUGF0aCIsIm1heERlc2lyZWRTaXplIiwicm91bmQiLCJzaGFwZUZyb21UZXh0IiwidGV4dERhdGEiLCJ0ZXh0IiwiZm9udEZhbWlseSIsImZvbnRTaXplIiwiZm9udCIsIm1lYXN1cmVUZXh0IiwiY2VpbCIsImFjdHVhbEJvdW5kaW5nQm94UmlnaHQiLCJhY3R1YWxCb3VuZGluZ0JveExlZnQiLCJhY3R1YWxCb3VuZGluZ0JveEFzY2VudCIsImFjdHVhbEJvdW5kaW5nQm94RGVzY2VudCIsInBhZGRpbmciLCJmaWxsVGV4dCIsImFwcGx5IiwiYXJndW1lbnRzIiwiY3JlYXRlIiwid2luZG93Iiwic2VsZiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/canvas-confetti/dist/confetti.module.mjs\n");

/***/ })

};
;